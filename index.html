<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/08/hello-world/" class="article-date">
  <time datetime="2016-11-08T03:43:46.879Z" itemprop="datePublished">2016-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/08/hello-world/" data-id="civ9405sn001cakqttgtrcizg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-RxJava-二-原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/22/Android-浅析-RxJava-二-原理/" class="article-date">
  <time datetime="2016-09-22T04:14:52.000Z" itemprop="datePublished">2016-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/22/Android-浅析-RxJava-二-原理/">Android 浅析 RxJava (二) 原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>原理解析我们从三个部分入手：1、基本流程梳理，2、lift的实现原理，3、线程切换原理。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;ArrayList&lt;String&gt;&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> ArrayList&lt;String&gt;&gt; subscriber)</span> </span>&#123;</div><div class="line">                  subscriber.onNext(T);</div><div class="line">                  subscriber.onCompleted();</div><div class="line">              &#125;</div><div class="line">          &#125;)</div><div class="line">          .subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;&#125;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;&#125;</div><div class="line">          &#125;);</div></pre></td></tr></table></figure>
<p>这就是Rxjava的基本使用流程。我们从流程开始分析：</p>
<h3 id="Observable-create"><a href="#Observable-create" class="headerlink" title="Observable.create()"></a>Observable.create()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Step 1:</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(hook.onCreate(f));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Step 2:</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.onSubscribe = f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两步是创建了一个Observable对象和OnSubscribe对象。</p>
<h3 id="Observable-subscribe"><a href="#Observable-subscribe" class="headerlink" title="Observable.subscribe()"></a>Observable.subscribe()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line">    <span class="comment">// new Subscriber so onStart it</span></div><div class="line">    subscriber.onStart();</div><div class="line">    </div><div class="line">    <span class="comment">// allow the hook to intercept and/or decorate</span></div><div class="line">    hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步的操作实际上就是调用了 Observable.onSubscribe.call(subscriber);</p>
<p>整理下基本流程分两步：<br>1、创建Observable, OnSubscribe, Subscriber 三个对象<br>2、调用Observable的subscribe方法</p>
<p>那么他们最终的程序调用顺序是：<br>1、Observable.subscribe()<br>2、Observable.OnSubscribe.call()<br>3、Subscriber.onNext()</p>
<h2 id="map操作符和lift原理"><a href="#map操作符和lift原理" class="headerlink" title="map操作符和lift原理"></a>map操作符和lift原理</h2><p>RxJava之所以好用是因为它提供了很多非常简洁的操作符动作，利用lift原理可以很流畅的实现操作的顺序过度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;ArrayList&lt;String&gt;&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> ArrayList&lt;String&gt;&gt; subscriber)</span> </span>&#123;</div><div class="line">                  subscriber.onNext(T);</div><div class="line">                  subscriber.onCompleted();</div><div class="line">              &#125;</div><div class="line">          &#125;)</div><div class="line">          .map(<span class="keyword">new</span> Func1&lt;String, String&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;)</div><div class="line">          .subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;&#125;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;&#125;</div><div class="line">          &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Observable-map"><a href="#Observable-map" class="headerlink" title="Observable.map()"></a>Observable.map()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; func)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorMap&lt;T, R&gt;(func));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实可以看到我们的map函数的主要实现是调用了litf方法，并在里面传入的是OperatorMap的对象。</p>
<h3 id="Observable-lift"><a href="#Observable-lift" class="headerlink" title="Observable lift()"></a>Observable lift()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;R&gt;(<span class="keyword">new</span> OnSubscribe&lt;R&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</div><div class="line">            Subscriber&lt;? <span class="keyword">super</span> T&gt; st = hook.onLift(operator).call(o);</div><div class="line">            st.onStart();</div><div class="line">            onSubscribe.call(st);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>首先 new 了一个 Func函数, 保存在了 <code>OperatorMap.transform</code> 中。</li>
<li>new了一个新的 Observable. 这个 Observable 的构造函数中, 传入了一个新的 OnSubscribe。<br>lift的重点就在这个OnSubscribe里面。</li>
</ol>
<p>先来看下OperatorMap的代码(只列出核心)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorMap</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Operator</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; o) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;T&gt;(o) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                o.onNext(transformer.call(t));</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到从<code>hook.onLift(operator).call(o);</code>这里创建出来的Subscriber的call函数里主要做的就是<code>transformer.call(t)</code>也就是转换的操作。然后再将其转换的结果返回给onNext。</p>
<h3 id="lift-流程总结"><a href="#lift-流程总结" class="headerlink" title="lift 流程总结"></a>lift 流程总结</h3><p>总结下整个回调流程：</p>
<ol>
<li>调用Create函数，创建一个新的Observable，并且创建一个OnSubscribe。</li>
<li>调用Map函数，再创建一个新的Observable，同时也创建一个新的OnSubscribe。并且其中的<code>OnSubscribe.call()</code>方法调用了第一步的<code>Observable.onSubscribe.call</code>方法，最后将结果进行<code>transform</code> 操作。</li>
<li>最后将拿到的<code>transform</code> 操作结果传给我们最后的<code>onNext()</code>方法中作为结果。</li>
</ol>
<h2 id="subscribeOn-和observeOn-线程切换原理"><a href="#subscribeOn-和observeOn-线程切换原理" class="headerlink" title="subscribeOn()和observeOn()线程切换原理"></a>subscribeOn()和observeOn()线程切换原理</h2><p>Rxjava还有另外一个原因让它在使用上非常简洁，就是线程处理上。<br>首先来看下他们的作用域<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO 线程，由 subscribeOn() 指定</span></div><div class="line">    .subscribeOn(Schedulers.io())</div><div class="line">    .observeOn(Schedulers.newThread())</div><div class="line">    .map(mapOperator) <span class="comment">// 新线程，由 observeOn() 指定</span></div><div class="line">    .observeOn(Schedulers.io())</div><div class="line">    .map(mapOperator2) <span class="comment">// IO 线程，由 observeOn() 指定</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread) </div><div class="line">    .subscribe(subscriber);  <span class="comment">// Android 主线程，由 observeOn() 指定</span></div></pre></td></tr></table></figure></p>
<p>我们先上一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;ArrayList&lt;String&gt;&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> ArrayList&lt;String&gt;&gt; subscriber)</span> </span>&#123;</div><div class="line">                  subscriber.onNext(T);</div><div class="line">                  subscriber.onCompleted();</div><div class="line">              &#125;</div><div class="line">          &#125;)</div><div class="line">          .subscribeOn(Schedulers.io())</div><div class="line">          .observeOn(Schedulers.newThread())</div><div class="line">          .subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;&#125;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;&#125;</div><div class="line">          &#125;);</div></pre></td></tr></table></figure></p>
<p>首先来看下observeOn()代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">        <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler));</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> ImmediateScheduler) &#123;</div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child);</div><div class="line">        parent.init();</div><div class="line">        <span class="keyword">return</span> parent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到observeOn其实也是调用了OperatorObserveOn类来实现的，本意上所有的Rxjava都是以操作符的形式来调用。接下来就是OperatorObserveOn的<code>call()</code>方法，该方法回根据传入的Subscriber类型决定返回的方式。<br>总结来说就是通过<code>lift()</code>方法将接下来传入执行的subscribe方法通过新的线程方式执行，并且在结束后再接着往下走。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Rxjava 的原理我们并没有每条都往里深入，因为rxjava的代码复杂度很高，需要跟着代码有耐心的往下走才能看清，建议读者可以根据源码一步步跟进。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/22/Android-浅析-RxJava-二-原理/" data-id="civ9405s7000takqtvxg54lwi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开源库/">开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-RxJava-一-使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/22/Android-浅析-RxJava-一-使用/" class="article-date">
  <time datetime="2016-09-22T04:00:41.000Z" itemprop="datePublished">2016-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/22/Android-浅析-RxJava-一-使用/">Android 浅析 RxJava (一) 使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.<br>RxJava 是一个被设计实现为灵活扩展功能的 java 虚拟机：一个由异步和事件组成的观测序列为基础的程序库。</p>
<p>It extends the observer pattern to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.<br>它扩展了观察者模式来支持data/events序列和增加了operators来允许你把序列以声明方式组成在一起并一边将关注的事情抽象化，比如低线程，同步，线程安全和并发数据结构。</p>
</blockquote>
<p>RxJava 是一个响应式编程框架，采用观察者设计模式。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="Step-1：创建Observer"><a href="#Step-1：创建Observer" class="headerlink" title="Step 1：创建Observer"></a>Step 1：创建Observer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observer&lt;T&gt; observer = <span class="keyword">new</span> Observer&lt;T&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T s)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>除了Observer，还有一个内置的Subscriber类实现了Observer的抽象类。Subscriber类对Observer类进行了扩展。<br>它们的实现基本上是一样的，对于区别，主要有这两点：</p>
<ol>
<li>onStart(): 这是 Subscriber 增加的方法。在 subscribe 刚开始，而事件还未发送之前被调用。</li>
<li>unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。</li>
</ol>
<h3 id="Step-2：创建Observable"><a href="#Step-2：创建Observable" class="headerlink" title="Step 2：创建Observable"></a>Step 2：创建Observable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;T&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(T);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>RxJava 还提供了其它快速创建事件队列的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>);</div><div class="line"></div><div class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>&#125;;</div><div class="line">Observable observable = Observable.from(words);</div></pre></td></tr></table></figure></p>
<h3 id="Step-3：Subscribe"><a href="#Step-3：Subscribe" class="headerlink" title="Step 3：Subscribe"></a>Step 3：Subscribe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div><div class="line"><span class="comment">// 或者：</span></div><div class="line">observable.subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>Observable.subscribe(Subscriber) 的内部实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subscriber.onStart();</div><div class="line">onSubscribe.call(subscriber);</div></pre></td></tr></table></figure></p>
<p>在接收到订阅后马上会开始发送事件。</p>
<h4 id="不完整定义回调"><a href="#不完整定义回调" class="headerlink" title="不完整定义回调"></a>不完整定义回调</h4><p>subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="comment">// onNext()</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.d(tag, s);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line">    <span class="comment">// onError()</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        <span class="comment">// Error handling</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Action0 onCompletedAction = <span class="keyword">new</span> Action0() &#123;</div><div class="line">    <span class="comment">// onCompleted()</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"completed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></div><div class="line">observable.subscribe(onNextAction);</div><div class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span></div><div class="line">observable.subscribe(onNextAction, onErrorAction);</div><div class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span></div><div class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</div></pre></td></tr></table></figure></p>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将字符串数组 names 中的所有字符串依次打印出来：</span></div><div class="line">String[] names = ...;</div><div class="line">Observable.from(names)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            Log.d(tag, name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="Scheduler-线程控制"><a href="#Scheduler-线程控制" class="headerlink" title="Scheduler 线程控制"></a>Scheduler 线程控制</h2><blockquote>
<p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">    .subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span> </span>&#123;</div><div class="line">            Log.d(tag, <span class="string">"number:"</span> + number);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<ol>
<li>subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。</li>
<li>observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。</li>
</ol>
<p>这段代码就是说，由 subscribeOn(Schedulers.io()) 的指定，创建的事件内容<code>(1,2,3,4)</code>将由io线程发出，而由 observeOn(AndroidScheculers.mainThread()) 的指定，subscriber 数字的 Log 将发生在主线程。</p>
<h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="Operators-操作符"><a href="#Operators-操作符" class="headerlink" title="Operators 操作符"></a>Operators 操作符</h3><blockquote>
<p>Operators在消息发送者Observable和消息消费者Subscriber之间起到操纵消息的作用。</p>
</blockquote>
<h4 id="map-操作符"><a href="#map-操作符" class="headerlink" title="map 操作符"></a>map 操作符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">    .map(<span class="keyword">new</span> Func1&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> s + <span class="string">" -Dan"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(s -&gt; System.out.println(s));</div></pre></td></tr></table></figure>
<p>当我们在消息的过程中对消息进行转换，最简单的方法就是使用 map 操作符。<br>map()函数的特点是：它不一定发送和原始的Observable一样的数据类型。</p>
<h4 id="flatMap-操作符"><a href="#flatMap-操作符" class="headerlink" title="flatMap 操作符"></a>flatMap 操作符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable&lt;ArrayList&lt;String&gt;&gt; query(String text);</div><div class="line">query(<span class="string">"a lot text"</span>)</div><div class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;ArrayList&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(ArrayList&lt;String&gt; s)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Observable.from(s);</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">            System.out.println(s);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>利用 flatMap 操作符可以很方便的将一个 list 的字符串分开发出来，在 faltMap 函数内的 Func1跟之前的 Action1 意思一样，并且返回值是一个新的 Observable 对象。</p>
<p>至于更多的操作符会在未来添加。</p>
<h2 id="最后在说下RxJava-的实际使用意义"><a href="#最后在说下RxJava-的实际使用意义" class="headerlink" title="最后在说下RxJava 的实际使用意义"></a>最后在说下RxJava 的实际使用意义</h2><ul>
<li>Observable 和 Subscriber 他们本身就是一个处理事件的通用框架。</li>
<li>Observable 和 Subscriber 在它们之间的一系列转换步骤是相互独立的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/22/Android-浅析-RxJava-一-使用/" data-id="civ9405s7000rakqt4z757bly" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开源库/">开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-注解-Dependency-injection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/Java-注解-Dependency-injection/" class="article-date">
  <time datetime="2016-09-21T13:57:32.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/Java-注解-Dependency-injection/">Java 注解 Dependency injection</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="现有的开源库"><a href="#现有的开源库" class="headerlink" title="现有的开源库"></a>现有的开源库</h2><ul>
<li>RoboGuice</li>
<li>Android Annotations</li>
<li>Dragger</li>
<li>ButterKnife</li>
<li>Transfuse</li>
</ul>
<h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h2><p>从三个方向了解注解：</p>
<ol>
<li>注解是什么？</li>
<li>注解有什么用？</li>
<li>注解怎么用？</li>
</ol>
<h3 id="注解是什么"><a href="#注解是什么" class="headerlink" title="注解是什么"></a>注解是什么</h3><blockquote>
<p>注解(Annotation)，也叫元数据。一种代码级别的说明，是一种将程序中的元素与任何信息关联一起的途径和方法。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。</p>
</blockquote>
<h3 id="注解有什么用"><a href="#注解有什么用" class="headerlink" title="注解有什么用"></a>注解有什么用</h3><blockquote>
<ol>
<li>创建文档。</li>
<li>跟踪代码中的依赖性。</li>
<li>甚至执行基本编译时检查。</li>
</ol>
</blockquote>
<p>在Java 5.0 中java.lang包有三个标准Annotation类型。</p>
<ol>
<li>标准 Annotation (JDK内置系统注解)</li>
</ol>
<p>标准 Annotation 是指 Java 自带的几个 Annotation，例如： @Override, @Deprecated, @SuppressWarnings。</p>
<ol>
<li>元 Annotation (元注解)</li>
</ol>
<p>元 Annotation 是指用来定义 Annotation 的 Annotation，例如：@Retention, @Target, @Inherited, @Documented。</p>
<ol>
<li>自定义 Annotation (自定义注解)</li>
</ol>
<p>自定义 Annotation 表示自己根据需要定义的 Annotation，定义时需要用到元 Annotation。</p>
<h3 id="注解怎么用"><a href="#注解怎么用" class="headerlink" title="注解怎么用"></a>注解怎么用</h3><blockquote>
<p>注解的语法比较简单，就是在前面添加<code>@</code>符号，后面的语法就更Java语法一致。</p>
</blockquote>
<h4 id="标准-Annotation"><a href="#标准-Annotation" class="headerlink" title="标准 Annotation"></a>标准 Annotation</h4><p>我们列出三个例子：</p>
<ol>
<li>@Override</li>
<li>@Deprecated</li>
<li>@SuppressWarnnings</li>
</ol>
<h5 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h5><blockquote>
<p>用于修饰此方法覆盖了父类的方法。</p>
</blockquote>
<p>@Override 是一个标记注解类型，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果重载的方法写错了在编译期会有警告出现。</p>
<h5 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h5><blockquote>
<p>用于修饰已经过时的方法。</p>
</blockquote>
<p>@Deprecated是一个标记注解。当一个类型或者类型成员使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。这个标记注解具有继承性，可被子类继承。</p>
<h5 id="SuppressWarnnings"><a href="#SuppressWarnnings" class="headerlink" title="@SuppressWarnnings"></a>@SuppressWarnnings</h5><blockquote>
<p>用于通知java编译器禁止特定的编译警告。</p>
</blockquote>
<p>@SuppressWarnings 被用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告。@SuppressWarnings使用格式有这几种：</p>
<ol>
<li>@SuppressWarnings(value={“deprecation”, “unchecked”})</li>
<li>@SuppressWarnings({“deprecation”, “unchecked”})</li>
<li>@SuppressWarnings(“unchecked”)</li>
</ol>
<p>常见的@SuppressWarnings参数值：</p>
<ul>
<li><strong>all</strong> to suppress all warnings</li>
<li><strong>boxing</strong> to suppress warnings relative to boxing/unboxing operations</li>
<li><strong>cast</strong> to suppress warnings relative to cast operations</li>
<li><strong>dep-ann</strong> to suppress warnings relative to deprecated annotation</li>
<li><strong>deprecation</strong> to suppress warnings relative to deprecation</li>
<li><strong>fallthrough</strong> to suppress warnings relative to missing breaks in switch statements</li>
<li><strong>finally</strong> to suppress warnings relative to finally block that don’t return</li>
<li><strong>hiding</strong> to suppress warnings relative to locals that hide variable</li>
<li><strong>incomplete-switch</strong> to suppress warnings relative to missing entries in a switch statement (enum case)</li>
<li><strong>nls</strong> to suppress warnings relative to non-nls string literals</li>
<li><strong>null</strong> to suppress warnings relative to null analysis</li>
<li><strong>rawtypes</strong> to suppress warnings relative to un-specific types when using generics on class params</li>
<li><strong>restriction</strong> to suppress warnings relative to usage of discouraged or forbidden references</li>
<li><strong>serial</strong> to suppress warnings relative to missing serialVersionUID field for a serializable class</li>
<li><strong>static-access</strong> to suppress warnings relative to incorrect static access</li>
<li><strong>synthetic-access</strong> to suppress warnings relative to unoptimized access from inner classes</li>
<li><strong>unchecked</strong> to suppress warnings relative to unchecked operations</li>
<li><strong>unqualified-field-access</strong> to suppress warnings relative to field access unqualified</li>
<li><strong>unused</strong> to suppress warnings relative to unused code</li>
</ul>
<h4 id="元-Annotation"><a href="#元-Annotation" class="headerlink" title="元 Annotation"></a>元 Annotation</h4><p>元注解的作用就是负责注解其他注解。在Java 5.0 中有四个标准元注解：</p>
<ol>
<li>@Target</li>
<li>@Retention</li>
<li>@Documented</li>
<li>@Inherited</li>
</ol>
<h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><p>定义了Annotation所修饰的对象范围：可被用于 packages、types(类、接口、枚举、Annotation类型)、类型成员(方法、构造方法、成员变量、枚举值)、方法参数和本地变量(如循环变量、catch参数)。<br>取值类型有这么几个：</p>
<ol>
<li>CONSTRUCTOR:用于描述构造器</li>
<li>FIELD:用于描述域</li>
<li>LOCAL_VARIABLE:用于描述局部变量</li>
<li>METHOD:用于描述方法</li>
<li>PACKAGE:用于描述包</li>
<li>PARAMETER:用于描述参数</li>
<li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
</ol>
<h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><p>定义了该Annotation被保留的时间长短。<br>取值类型有这么几个：</p>
<ol>
<li>SOURCE:在源文件中有效(即源文件保留)</li>
<li>CLASS:在class文件中有效(即class保留)</li>
<li>RUNTIME:在运行时有效(即运行时保留)</li>
</ol>
<h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><p>用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被如javadoc此类的工具文档化。</p>
<h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><p>这是一个标记注解，阐述了某个被标注的类型是被继承的。</p>
<h4 id="自定义-Annotation"><a href="#自定义-Annotation" class="headerlink" title="自定义 Annotation"></a>自定义 Annotation</h4><p>通过使用<code>@interface</code>符号来完成自定义注解，自定义注解不能继承其它注解或接口。可以通过default来声明参数的默认值。</p>
<p>注解格式：<br>public @interface 注解名 {定义体}</p>
<p>支持的数据类型：</p>
<ol>
<li>所有基本数据类型（int,float,boolean,byte,double,char,long,short)</li>
<li>String类型</li>
<li>Class类型</li>
<li>enum类型</li>
<li>Annotation类型</li>
<li>以上所有类型的数组</li>
</ol>
<p>备注：</p>
<ol>
<li>如果只有一个参数成员,最好把参数名称设为”value”，后加小括号。</li>
<li>只能用public或默认(default)这两个访问权修饰。</li>
</ol>
<p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FileName &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FileType &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Color&#123;BULE,RED,GREEN&#125;;</div><div class="line">    <span class="function">Color <span class="title">fruitColor</span><span class="params">()</span> <span class="keyword">default</span> Color.GREEN</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line"><span class="meta">@FileName</span>(<span class="string">"Safe"</span>)</div><div class="line"><span class="keyword">private</span> String FileName;</div></pre></td></tr></table></figure></p>
<h3 id="注解处理器类库"><a href="#注解处理器类库" class="headerlink" title="注解处理器类库"></a>注解处理器类库</h3><p>最后这里介绍下注解处理类库:<br><code>java.lang.reflect.AnnotatedElement</code><br>可以通过它处理很多复杂的注解工作。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1645265-6d9c0bfb6b9c5127.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注解学习图"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/Java-注解-Dependency-injection/" data-id="civ9405sn0017akqt8geqvn5b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/注解/">注解</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-ButterKnife-二-源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/Android-浅析-ButterKnife-二-源码解析/" class="article-date">
  <time datetime="2016-09-21T13:49:42.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/Android-浅析-ButterKnife-二-源码解析/">Android 浅析 ButterKnife (二) 源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>这章将会根据由浅入深的过程浅析ButterKnife的注解方式。</p>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><ul>
<li>butterknife</li>
<li>butterknife-annotations</li>
<li>butterknife-compiler</li>
</ul>
<p>可以看到工程的目录结构还是很清楚的<br><code>butterknife</code>负责工程的主要逻辑调用入口。<br><code>butterknife-annotations</code>负责所有注解的自定义文件。<br><code>butterknife-compiler</code>负责在编译时解析Annotations。</p>
<h2 id="butterknife-annotations"><a href="#butterknife-annotations" class="headerlink" title="butterknife-annotations"></a>butterknife-annotations</h2><p>这里面的文件都是由注解组成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Bind a field to the view for the specified ID. The view will automatically be cast to the field</div><div class="line"> * type.</div><div class="line"> * &lt;pre&gt;&lt;code&gt;</div><div class="line"> * &#123;<span class="doctag">@literal</span> @&#125;Bind(R.id.title) TextView title;</div><div class="line"> * &lt;/code&gt;&lt;/pre&gt;</div><div class="line"> */</div><div class="line"><span class="meta">@Retention</span>(CLASS) <span class="meta">@Target</span>(FIELD)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bind &#123;</div><div class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></div><div class="line">  <span class="meta">@IdRes</span> <span class="keyword">int</span>[] value();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例如我们最经典的<code>Bind</code>方法的注解就是在这里定义的，这里通过注释我们可以很直接知道这些注解做的是什么就不再一一解析了。</p>
<h2 id="butterknife-compiler"><a href="#butterknife-compiler" class="headerlink" title="butterknife-compiler"></a>butterknife-compiler</h2><p>接下来我们看编译过程，这里是butterknife的主要部分。<br>所有的注解要在编译时进行解析，都需要自定义一个类继承于<code>javax.annotation.processing.AbstractProcessor</code>，通过复写其中的方法来实现。</p>
<p>先来看下支持注解的类类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList(<span class="comment">//</span></div><div class="line">    OnCheckedChanged.class, <span class="comment">//</span></div><div class="line">    OnClick.class, <span class="comment">//</span></div><div class="line">    OnEditorAction.class, <span class="comment">//</span></div><div class="line">    OnFocusChange.class, <span class="comment">//</span></div><div class="line">    OnItemClick.class, <span class="comment">//</span></div><div class="line">    OnItemLongClick.class, <span class="comment">//</span></div><div class="line">    OnItemSelected.class, <span class="comment">//</span></div><div class="line">    OnLongClick.class, <span class="comment">//</span></div><div class="line">    OnPageChange.class, <span class="comment">//</span></div><div class="line">    OnTextChanged.class, <span class="comment">//</span></div><div class="line">    OnTouch.class <span class="comment">//</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">//获取支持注解的类型</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</div><div class="line">  Set&lt;String&gt; types = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line">  types.add(Bind.class.getCanonicalName());</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123;</div><div class="line">    types.add(listener.getCanonicalName());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  types.add(BindArray.class.getCanonicalName());</div><div class="line">  types.add(BindBitmap.class.getCanonicalName());</div><div class="line">  types.add(BindBool.class.getCanonicalName());</div><div class="line">  types.add(BindColor.class.getCanonicalName());</div><div class="line">  types.add(BindDimen.class.getCanonicalName());</div><div class="line">  types.add(BindDrawable.class.getCanonicalName());</div><div class="line">  types.add(BindInt.class.getCanonicalName());</div><div class="line">  types.add(BindString.class.getCanonicalName());</div><div class="line">  types.add(Unbinder.class.getCanonicalName());</div><div class="line"></div><div class="line">  <span class="keyword">return</span> types;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们可以看到基本都涵盖了我们在<code>butterknife-annotations</code>自定义的文件。</p>
<p>接着我们来看主要的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</div><div class="line">  <span class="comment">//查找和解析注解</span></div><div class="line">  Map&lt;TypeElement, BindingClass&gt; targetClassMap = findAndParseTargets(env);</div><div class="line"></div><div class="line">  <span class="comment">//循环遍历拿出注解中的键值</span></div><div class="line">  <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123;</div><div class="line">    TypeElement typeElement = entry.getKey();</div><div class="line">    BindingClass bindingClass = entry.getValue();</div><div class="line">    <span class="comment">//写进文件，生成辅助类</span></div><div class="line">    bindingClass.brewJava().writeTo(filer);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们看到主要的<code>process</code>函数里实现的就三个功能<br>1:查找和解析注解；<br>2:循环遍历拿出注解中的键值；<br>3:写进文件，生成辅助类。</p>
<p>我们先来看第一个功能，查找和解析注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;TypeElement, BindingClass&gt; <span class="title">findAndParseTargets</span><span class="params">(RoundEnvironment env)</span> </span>&#123;</div><div class="line">    Map&lt;TypeElement, BindingClass&gt; targetClassMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</div><div class="line">    Set&lt;TypeElement&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// Process each @Bind element.</span></div><div class="line">    <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(Bind.class)) &#123;</div><div class="line">      <span class="keyword">if</span> (!SuperficialValidation.validateElement(element)) <span class="keyword">continue</span>;</div><div class="line">      parseBind(element, targetClassMap, erasedTargetNames);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Process each annotation that corresponds to a listener.</span></div><div class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123;</div><div class="line">      findAndParseListener(env, listener, targetClassMap, erasedTargetNames);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Process each @BindInt element.</span></div><div class="line">    <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindInt.class)) &#123;</div><div class="line">      <span class="keyword">if</span> (!SuperficialValidation.validateElement(element)) <span class="keyword">continue</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        parseResourceInt(element, targetClassMap, erasedTargetNames);</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        logParsingError(element, BindInt.class, e);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们拿了一个比较简单的<code>@BindInt</code>来分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseResourceInt</span><span class="params">(Element element, Map&lt;TypeElement, BindingClass&gt; targetClassMap,</span></span></div><div class="line">    Set&lt;TypeElement&gt; erasedTargetNames) &#123;</div><div class="line">  <span class="keyword">boolean</span> hasError = <span class="keyword">false</span>;</div><div class="line">  TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</div><div class="line">  ...</div><div class="line">  <span class="comment">// Verify common generated code restrictions.</span></div><div class="line">  hasError |= isInaccessibleViaGeneratedCode(BindInt.class, <span class="string">"fields"</span>, element);</div><div class="line">  hasError |= isBindingInWrongPackage(BindInt.class, element);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (hasError) &#123;<span class="keyword">return</span>;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// Assemble information on the field.</span></div><div class="line">  String name = element.getSimpleName().toString();</div><div class="line">  <span class="keyword">int</span> id = element.getAnnotation(BindInt.class).value();</div><div class="line"></div><div class="line">  BindingClass bindingClass = getOrCreateTargetClass(targetClassMap, enclosingElement);</div><div class="line">  FieldResourceBinding binding = <span class="keyword">new</span> FieldResourceBinding(id, name, <span class="string">"getInteger"</span>, <span class="keyword">false</span>);</div><div class="line">  bindingClass.addResource(binding);</div><div class="line"></div><div class="line">  erasedTargetNames.add(enclosingElement);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们首先看到<code>isInaccessibleViaGeneratedCode()</code>，它里面判断了三个点：</p>
<ol>
<li>验证方法修饰符不能为<code>private</code>和<code>static</code>。</li>
<li>验证包含类型不能为非<code>Class</code>。</li>
<li>验证包含类的可见性并不是<code>private</code>。</li>
</ol>
<p>接着我们来看<code>isBindingInWrongPackage</code>，它判断了这个类的包名，包名不能以android.和java.开头，butterknife不可以在Android Framework和JDK框架内部使用。</p>
<p>最后就是调用<code>getOrCreateTargetClass</code>函数获取或者生成一个绑定类，并将之存入数组。</p>
<p>接下来我们肯定要分析最常用的注解<code>@Bind</code>了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBind</span><span class="params">(Element element, Map&lt;TypeElement, BindingClass&gt; targetClassMap, Set&lt;TypeElement&gt; erasedTargetNames)</span> </span>&#123;</div><div class="line">  <span class="comment">// Verify common generated code restrictions.</span></div><div class="line">  <span class="keyword">if</span> (isInaccessibleViaGeneratedCode(Bind.class, <span class="string">"fields"</span>, element)</div><div class="line">      || isBindingInWrongPackage(Bind.class, element)) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  TypeMirror elementType = element.asType();</div><div class="line">  <span class="keyword">if</span> (elementType.getKind() == TypeKind.ARRAY) &#123;</div><div class="line">    parseBindMany(element, targetClassMap, erasedTargetNames);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LIST_TYPE.equals(doubleErasure(elementType))) &#123;</div><div class="line">    parseBindMany(element, targetClassMap, erasedTargetNames);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    parseBindOne(element, targetClassMap, erasedTargetNames);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看出这里第一步也是判断两个<code>isInaccessibleViaGeneratedCode()</code>和<code>isBindingInWrongPackage</code>的条件，接着通过<code>parseBindMany()</code>来解析这个注解：</p>
<ol>
<li>验证这个类型是一个<code>List</code>还是一个<code>array</code>。</li>
<li>验证这个目标类型是否继承自<code>View</code>。</li>
<li>在作用域里组装信息。</li>
<li>当然，最后将生成的<code>BindingClass</code>存入数组中。</li>
</ol>
<p>分析完<code>findAndParseTargets</code>我们接着回到<code>process</code>往下看<code>bindingClass.brewJava()</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">JavaFile <span class="title">brewJava</span><span class="params">()</span> </span>&#123;</div><div class="line">    TypeSpec.Builder result = TypeSpec.classBuilder(className)</div><div class="line">        .addModifiers(PUBLIC)</div><div class="line">        .addTypeVariable(TypeVariableName.get(<span class="string">"T"</span>, ClassName.bestGuess(targetClass)));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (parentViewBinder != <span class="keyword">null</span>) &#123;</div><div class="line">      result.superclass(ParameterizedTypeName.get(ClassName.bestGuess(parentViewBinder),</div><div class="line">          TypeVariableName.get(<span class="string">"T"</span>)));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      result.addSuperinterface(ParameterizedTypeName.get(VIEW_BINDER, TypeVariableName.get(<span class="string">"T"</span>)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hasUnbinder()) &#123;</div><div class="line">      result.addType(createUnbinderClass());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    result.addMethod(createBindMethod());</div><div class="line"></div><div class="line">    <span class="keyword">return</span> JavaFile.builder(classPackage, result.build())</div><div class="line">        .addFileComment(<span class="string">"Generated code from Butter Knife. Do not modify!"</span>)</div><div class="line">        .build();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这个函数通过将我们绑定类的信息写入到文件外还负责创建绑定和创建解除绑定。<br>在将绑定函数写入到文件后，整个编译器的注解方法就结束了。接下来就到运行时的注解过程了。</p>
<h2 id="butterknife"><a href="#butterknife" class="headerlink" title="butterknife"></a>butterknife</h2><blockquote>
<p>Field and method binding for Android views. Use this class to simplify finding views and attaching listeners by binding them with annotations.<br>这是关于ButterKnife类的说明，关于ButterKnife的使用基本都是通过这个主类来实现的。<br>这里面最关键的函数就数<code>bind()</code>了：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</div><div class="line">    bind(target, target, Finder.ACTIVITY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个bind函数实际上都是通过相同的函数不同参数实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Object target, @NonNull Object source, @NonNull Finder finder)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; targetClass = target.getClass();</div><div class="line"></div><div class="line">    ViewBinder&lt;Object&gt; viewBinder = findViewBinderForClass(targetClass);</div><div class="line">    viewBinder.bind(finder, target, source);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先通过<code>findViewBinderForClass</code>生成每个类，然后再调用这些类的bind方法进行绑定，这些类的方法都是在编译期通过<code>createBindMethod()</code>方法一个个生成的。这些也就是辅助类的用处了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是对ButterKnife的浅析，具体来说就是在你写下注解后，ButterKnife会帮你在编译期帮你把代码补全，然后在运行期来调用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/Android-浅析-ButterKnife-二-源码解析/" data-id="civ9405rs000fakqttxjmxohp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ButterKnife/">ButterKnife</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开源库/">开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-ButterKnife-一-使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/Android-浅析-ButterKnife-一-使用/" class="article-date">
  <time datetime="2016-09-21T13:44:49.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/Android-浅析-ButterKnife-一-使用/">Android 浅析 ButterKnife (一) 使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>Field and method binding for Android views which uses annotation processing to generate boilerplate code for you.<br>ButterKnife是一个用注解的方式生成公式化的代码将Android view的域和方法绑定一起的库。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Step-1-gradle"><a href="#Step-1-gradle" class="headerlink" title="Step 1 gradle"></a>Step 1 gradle</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile <span class="string">'com.jakewharton:butterknife:7.0.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Gradle中添加<code>butterknife</code>库。</p>
<h3 id="Step-2-Bind"><a href="#Step-2-Bind" class="headerlink" title="Step 2 Bind"></a>Step 2 Bind</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  <span class="meta">@Bind</span>(R.id.title) TextView title;</div><div class="line">  <span class="meta">@Bind</span>(R.id.subtitle) TextView subtitle;</div><div class="line">  <span class="meta">@Bind</span>(R.id.footer) TextView footer;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.simple_activity);</div><div class="line">    ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">// TODO Use fields...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码是帮你简化我们平常书写繁琐的<code>findViewById()</code>操作，在代码实际编译中的时候会自动转换成我们熟悉的代码，例子中的代码在实际编译中会生成这些代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ExampleActivity activity)</span> </span>&#123;</div><div class="line">  activity.subtitle = (android.widget.TextView) activity.findViewById(<span class="number">2130968578</span>);</div><div class="line">  activity.footer = (android.widget.TextView) activity.findViewById(<span class="number">2130968579</span>);</div><div class="line">  activity.title = (android.widget.TextView) activity.findViewById(<span class="number">2130968577</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="资源的BINDING"><a href="#资源的BINDING" class="headerlink" title="资源的BINDING"></a>资源的BINDING</h4><p>在对资源的Bind方法中有许多不同的注解可以用：<br><code>@BindBool, @BindColor, @BindDimen, @BindDrawable, @BindInt, @BindString</code><br>这些可以帮你在资源使用前绑定资源的id。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  <span class="meta">@BindString</span>(R.string.title) String title;</div><div class="line">  <span class="meta">@BindDrawable</span>(R.drawable.graphic) Drawable graphic;</div><div class="line">  <span class="meta">@BindColor</span>(R.color.red) <span class="keyword">int</span> red; <span class="comment">// int or ColorStateList field</span></div><div class="line">  <span class="meta">@BindDimen</span>(R.dimen.spacer) Float spacer; <span class="comment">// int (for pixel size) or float (for exact value) field</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ButterKnife的简单实用方法就是这些了，非常简单，接下来我们深入的看看深入使用方法。</p>
<h3 id="非Activity中使用"><a href="#非Activity中使用" class="headerlink" title="非Activity中使用"></a>非Activity中使用</h3><p>在非Activity中也可以同过绑定view 来实行绑定资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFloatWinCollectPage</span><span class="params">()</span> </span>&#123;</div><div class="line">    View view = findViewById(R.id.floatwin_collectpage_layout);</div><div class="line">    ButterKnife.bind(<span class="keyword">this</span>, view);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然这种绑定也可以用在holder这些繁琐的操作上面，在getview的函数里不断的绑定view也只需要一个操作就实现了。</p>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一</span></div><div class="line"><span class="meta">@Bind</span>(&#123; R.id.first_name, R.id.middle_name, R.id.last_name &#125;)</div><div class="line">List&lt;EditText&gt; nameViews;</div><div class="line"></div><div class="line"><span class="comment">// 方法二</span></div><div class="line">ButterKnife.apply(nameViews, DISABLE);</div><div class="line">ButterKnife.apply(nameViews, ENABLED, <span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ButterKnife.Action&lt;View&gt; DISABLE = <span class="keyword">new</span> ButterKnife.Action&lt;View&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(View view, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    view.setEnabled(<span class="keyword">false</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = <span class="keyword">new</span> ButterKnife.Setter&lt;View, Boolean&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(View view, Boolean value, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    view.setEnabled(value);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这两个方法都可以对资源进行批量操作，第一种是批量的赋值操作，第二种是对资源的批量显示或隐藏操作。<br><code>ButterKnife.apply(nameViews, View.ALPHA, 0.0f);</code><br>当然也可以对资源的属性进行操作了。</p>
<h3 id="LISTENER-绑定"><a href="#LISTENER-绑定" class="headerlink" title="LISTENER 绑定"></a>LISTENER 绑定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@OnClick</span>(R.id.submit)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@OnClick</span>(R.id.submit)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(Button button)</span> </span>&#123;</div><div class="line">  button.setText(<span class="string">"Hello!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过绑定可以快速的将一个方法和控件联系在一起。</p>
<p>当然也可以将多个id绑定到一个方法里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@OnClick</span>(&#123; R.id.door1, R.id.door2, R.id.door3 &#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pickDoor</span><span class="params">(DoorView door)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (door.hasPrizeBehind()) &#123;&#125; </div><div class="line">  <span class="keyword">else</span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="BINDING-RESET"><a href="#BINDING-RESET" class="headerlink" title="BINDING RESET"></a>BINDING RESET</h3><p>在绑定取消的时候调用<code>unbind</code>方法<br><code>ButterKnife.unbind(this);</code></p>
<h3 id="OPTIONAL-BINDINGS"><a href="#OPTIONAL-BINDINGS" class="headerlink" title="OPTIONAL BINDINGS"></a>OPTIONAL BINDINGS</h3><p>默认情况下，@Bind和监听绑定是必需的。如果目标视图不能找到一个异常将被抛出。<br>为了抑制这种行为，创造一个可选的绑定，添加注释@Nullable到方法最外边。<br><code>@Nullable @Bind(R.id.might_not_be_there) TextView mightNotBeThere;</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，要细看ButterKnife的代码应该直接看源码：<br><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">https://github.com/JakeWharton/butterknife</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/Android-浅析-ButterKnife-一-使用/" data-id="civ9405rs000cakqt3b5ys4su" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ButterKnife/">ButterKnife</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开源库/">开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-Volley-二-原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/Android-浅析-Volley-二-原理/" class="article-date">
  <time datetime="2016-09-21T13:38:27.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/Android-浅析-Volley-二-原理/">Android 浅析 Volley (二) 原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>本文通过对Volley源码进行分析来打通Volley的流程，并且知晓其原理，Volley的整体结构比较简单，但是细节有很多值得学习的地方。</p>
</blockquote>
<p><img src="http://ww3.sinaimg.cn/large/7669bef3gw1ezgdilrd3pj20f20e3ac8.jpg" alt="Volley 原理图"></p>
<h2 id="Volley初始化"><a href="#Volley初始化" class="headerlink" title="Volley初始化"></a>Volley初始化</h2><p><code>RequestQueue mQueue = Volley.newRequestQueue(this);</code><br>Volley的初始化就是简单的一行代码，但是里面做的事情比较复杂了。</p>
<h3 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h3><blockquote>
<p>这是Volley系统最主要的类之一，它用来初始化缓存目录和初始化下载响应队列。</p>
</blockquote>
<h4 id="Volley-newRequestQueue-…"><a href="#Volley-newRequestQueue-…" class="headerlink" title="Volley.newRequestQueue(…)"></a>Volley.newRequestQueue(…)</h4><blockquote>
<p>Creates a default instance of the worker pool and calls <code>RequestQueue.start()</code> on it.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HttpStack stack = <span class="keyword">new</span> HurlStack();</div><div class="line">Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line"></div><div class="line">File cacheDir = <span class="keyword">new</span> File(...);</div><div class="line">RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line"></div><div class="line">queue.start();</div></pre></td></tr></table></figure>
<p>这个函数不难，首先创建一个<code>HttpStack</code>对象和创建一个缓存文件，然后用创建的对象生成一个<code>RequestQueue</code>响应队列，最后调用<code>RequestQueue.start()</code>函数开始运行。</p>
<p>那么我们开始深入去看下，首先看下RequestQueue。</p>
<h3 id="RequestQueue"><a href="#RequestQueue" class="headerlink" title="RequestQueue"></a>RequestQueue</h3><blockquote>
<p>A request dispatch queue with a thread pool of dispatchers.<br>Calling <code>add(Request)</code> will enqueue the given Request for dispatch, resolving from either cache or network on a worker thread, and then delivering a parsed response on the main thread.</p>
</blockquote>
<h4 id="RequestQueue-RequestQueue-…"><a href="#RequestQueue-RequestQueue-…" class="headerlink" title="RequestQueue.RequestQueue(…)"></a>RequestQueue.RequestQueue(…)</h4><blockquote>
<p>Creates the worker pool.<br>初始化这里有几个关键的点：<br>1、DEFAULT_NETWORK_THREAD_POOL_SIZE：访问网络的线程数，默认是4条线程。<br>2、new ExecutorDelivery(new Handler(Looper.getMainLooper()))：新建一个用来推出网络响应和错误的类。<br>3、new NetworkDispatcher[threadPoolSize]：新建四条网络连接的线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@param cache A Cache to use for persisting responses to disk</span></div><div class="line"><span class="comment">//@param network A Network interface for performing HTTP requests</span></div><div class="line"><span class="comment">//@param threadPoolSize Number of network dispatcher threads to create</span></div><div class="line"><span class="comment">//@param delivery A ResponseDelivery interface for posting responses and errors</span></div><div class="line">RequestQueue(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize, ResponseDelivery delivery)</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="RequestQueue-Start"><a href="#RequestQueue-Start" class="headerlink" title="RequestQueue.Start()"></a>RequestQueue.Start()</h4><blockquote>
<p>Starts the dispatchers in this queue.</p>
</blockquote>
<p>首先是创建一个<code>CacheDispatcher</code>缓存发送者，它是一个缓存发送的线程，然后调用<code>CacheDispatcher</code>的<code>start()</code>函数。<br>然后循环创建<code>NetworkDispatcher</code>对象，因为默认的线程数是4，所以会循环4次创建网络调度（和相应的线程）到池大小，接着再调用<code>start()</code>函数。<br>简单来说当调用了Volley.newRequestQueue(context)之后，就会有<strong>五个线程</strong>一直在后台运行，不断等待网络请求的到来，其中CacheDispatcher是缓存线程，NetworkDispatcher是网络请求线程。</p>
<h4 id="RequestQueue-Stop"><a href="#RequestQueue-Stop" class="headerlink" title="RequestQueue.Stop()"></a>RequestQueue.Stop()</h4><blockquote>
<p>Stops the cache and network dispatchers.</p>
</blockquote>
<p>将所有缓存和网络发送者停止。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这几行简单的函数就创建了Volley的缓存和网络发送者队列，为以后的请求建立了机制。</p>
<h2 id="Volley添加请求"><a href="#Volley添加请求" class="headerlink" title="Volley添加请求"></a>Volley添加请求</h2><p>Volley的添加请求也很简单。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(...);</div><div class="line"></div><div class="line">mQueue.add(stringRequest);</div></pre></td></tr></table></figure></p>
<p>创建一个Request对象并且添加进Queue队列就行了。看起来简单，实际，好吧，很复杂。</p>
<h3 id="RequestQueue-1"><a href="#RequestQueue-1" class="headerlink" title="RequestQueue"></a>RequestQueue</h3><h4 id="RequestQueue-add"><a href="#RequestQueue-add" class="headerlink" title="RequestQueue.add()"></a>RequestQueue.add()</h4><p>这里函数本身比较简单易懂，首先将Request标识为当前队列，然后添加到<code>mCurrentRequests</code>当前请求队列里。接着判断是否可以缓存，如果不行则直接调用网络队列进行请求。最后插入请求到现阶段，如果已经有一个缓存键的请求在进行。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>添加的操作是比较简单，但难的是里面的具体过程，缓存请求和网络请求都是独立线程，在添加到队列之后就会不断的去获取然后对网络或者缓存进行处理。</p>
<h2 id="Volley-类分析"><a href="#Volley-类分析" class="headerlink" title="Volley 类分析"></a>Volley 类分析</h2><p><img src="http://ww4.sinaimg.cn/large/7669bef3gw1ezx3ienw1bj20uo16kn2f.jpg" alt="volley 类图"></p>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h4><h5 id="HttpStack"><a href="#HttpStack" class="headerlink" title="HttpStack"></a>HttpStack</h5><blockquote>
<p>Performs an HTTP request with the given parameters.<br>用于处理 Http 请求，返回请求结果的接口。</p>
</blockquote>
<h5 id="HurlStack"><a href="#HurlStack" class="headerlink" title="HurlStack"></a>HurlStack</h5><blockquote>
<p>based on HttpURLConnection.<br>实现 HttpStack 接口，基于HttpURLConnection进行各种请求方式的请求封装。</p>
</blockquote>
<h5 id="BasicNetwork"><a href="#BasicNetwork" class="headerlink" title="BasicNetwork"></a>BasicNetwork</h5><blockquote>
<p>A network performing Volley requests over an HttpStack.<br>一个基于HttpStack执行Volley请求的网络。</p>
</blockquote>
<p>调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。<br>主要实现了以下功能：<br>1、利用 HttpStack 执行网络请求。<br>2、如果 Request 中带有实体信息，如 Etag,Last-Modify 等，则进行缓存新鲜度的验证，并处理 304（Not Modify）响应。<br>3、如果发生超时，认证失败等错误，进行重试操作，直到成功、抛出异常(不满足重试策略等)结束。</p>
<h5 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h5><blockquote>
<p>An interface for performing requests.<br>接口类，作为网络请求的主要接口，传入需要访问的执行信息，并且返回一个<code>NetworkResponse</code>网络响应对象。</p>
</blockquote>
<h4 id="缓存类"><a href="#缓存类" class="headerlink" title="缓存类"></a>缓存类</h4><h5 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h5><blockquote>
<p>An interface for a cache keyed by a String with a byte array as data.<br>接口，一个可以获取请求结果，存储请求结果的缓存。</p>
</blockquote>
<h6 id="Entry-get-String-key"><a href="#Entry-get-String-key" class="headerlink" title="Entry get(String key)"></a>Entry get(String key)</h6><blockquote>
<p>通过 key 获取请求的缓存实体</p>
</blockquote>
<h6 id="void-put-String-key-Entry-entry"><a href="#void-put-String-key-Entry-entry" class="headerlink" title="void put(String key, Entry entry)"></a>void put(String key, Entry entry)</h6><blockquote>
<p>存入一个请求的缓存实体</p>
</blockquote>
<h6 id="void-remove-String-key"><a href="#void-remove-String-key" class="headerlink" title="void remove(String key)"></a>void remove(String key)</h6><blockquote>
<p>移除指定的缓存实体</p>
</blockquote>
<h6 id="void-clear"><a href="#void-clear" class="headerlink" title="void clear()"></a>void clear()</h6><blockquote>
<p>清空缓存</p>
</blockquote>
<h6 id="Entry内部类"><a href="#Entry内部类" class="headerlink" title="Entry内部类"></a>Entry内部类</h6><p>byte[] data : 请求返回的数据（Body 实体）<br>String etag Http : 响应首部中用于缓存新鲜度验证的 ETag<br>long serverDate Http : 响应首部中的响应产生时间<br>long ttl : 缓存的过期时间<br>long softTtl : 缓存的新鲜时间<br>Map<string, string=""> responseHeaders : 响应的 Headers<br>boolean isExpired() : 判断缓存是否过期，过期缓存不能继续使用<br>boolean refreshNeeded() : 判断缓存是否新鲜，不新鲜的缓存需要发到服务端做新鲜度的检测</string,></p>
<h5 id="NoCache"><a href="#NoCache" class="headerlink" title="NoCache"></a>NoCache</h5><blockquote>
<p>什么缓存都没有。不做任何操作的缓存实现类，可将它作为构建RequestQueue的参数以实现一个不带缓存的请求队列。</p>
</blockquote>
<h5 id="DiskBasedCache"><a href="#DiskBasedCache" class="headerlink" title="DiskBasedCache"></a>DiskBasedCache</h5><blockquote>
<p>Cache implementation that caches files directly onto the hard disk in the specified directory. The default disk usage size is 5MB, but is configurable.</p>
</blockquote>
<h6 id="void-initialize"><a href="#void-initialize" class="headerlink" title="void initialize()"></a>void initialize()</h6><blockquote>
<p>Initializes the DiskBasedCache by scanning for all files currently in the specified root directory. Creates the root directory if necessary.<br>初始化，扫描缓存目录得到所有缓存数据摘要信息放入内存。</p>
</blockquote>
<h6 id="Entry-get-String-key-1"><a href="#Entry-get-String-key-1" class="headerlink" title="Entry get(String key)"></a>Entry get(String key)</h6><blockquote>
<p>Returns the cache entry with the specified key if it exists, null otherwise.<br>从缓存中得到数据。先从缓存头中得到头部信息，然后读取缓存数据文件得到内容。</p>
</blockquote>
<h6 id="void-put-String-key-Entry-entry-1"><a href="#void-put-String-key-Entry-entry-1" class="headerlink" title="void put(String key, Entry entry)"></a>void put(String key, Entry entry)</h6><blockquote>
<p>Puts the entry with the specified key into the cache.<br>将数据文件内容保存到缓存。先检查缓存是否已满，已满则先删除缓存中部分数据，然后再新建缓存文件。</p>
</blockquote>
<h6 id="void-pruneIfNeeded-int-neededSpace"><a href="#void-pruneIfNeeded-int-neededSpace" class="headerlink" title="void pruneIfNeeded(int neededSpace)"></a>void pruneIfNeeded(int neededSpace)</h6><blockquote>
<p>Prunes the cache to fit the amount of bytes specified.<br>检查是否能再分配 neededSpace 字节的空间，如果不能则删除缓存中部分数据。</p>
</blockquote>
<h6 id="void-clear-1"><a href="#void-clear-1" class="headerlink" title="void clear()"></a>void clear()</h6><blockquote>
<p>Clears the cache. Deletes all cached files from disk.<br>清空缓存。 </p>
</blockquote>
<h6 id="void-remove-String-key-1"><a href="#void-remove-String-key-1" class="headerlink" title="void remove(String key)"></a>void remove(String key)</h6><blockquote>
<p>Removes the specified key from the cache if it exists.<br>删除缓存中某个元素。</p>
</blockquote>
<h6 id="CacheHeader"><a href="#CacheHeader" class="headerlink" title="CacheHeader"></a>CacheHeader</h6><blockquote>
<p>Handles holding onto the cache headers for an entry.<br>缓存文件头部信息在entry里。</p>
</blockquote>
<h5 id="ByteArrayPool"><a href="#ByteArrayPool" class="headerlink" title="ByteArrayPool"></a>ByteArrayPool</h5><blockquote>
<p>ByteArrayPool is a source and repository of <code>byte[]</code> objects.</p>
</blockquote>
<p>byte[] 的回收池，用于 byte[] 的回收再利用，减少了内存的分配和回收。 主要通过一个元素长度从小到大排序的ArrayList作为 byte[] 的缓存，另有一个按使用时间先后排序的ArrayList属性用于缓存满时清理元素。</p>
<h5 id="PoolingByteArrayOutputStream"><a href="#PoolingByteArrayOutputStream" class="headerlink" title="PoolingByteArrayOutputStream"></a>PoolingByteArrayOutputStream</h5><blockquote>
<p>A variation of <code>java.io.ByteArrayOutputStream</code> that uses a pool of byte[] buffers instead of always allocating them fresh, saving on heap churn.</p>
</blockquote>
<h5 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h5><p>身份认证接口，用于基本认证或者摘要认证。这个类是 Volley 用于和身份验证打通的接口，比如 OAuth，不过目前的使用不是特别广泛和 Volley 的内部结合也不是特别紧密。</p>
<h5 id="AndroidAuthenticator"><a href="#AndroidAuthenticator" class="headerlink" title="AndroidAuthenticator"></a>AndroidAuthenticator</h5><p>继承 Authenticator，基于 Android AccountManager 的认证交互实现类。</p>
<h3 id="基础类"><a href="#基础类" class="headerlink" title="基础类"></a>基础类</h3><h4 id="NetworkResponse"><a href="#NetworkResponse" class="headerlink" title="NetworkResponse"></a>NetworkResponse</h4><blockquote>
<p>Data and headers returned from performRequest(Request).<br>作为<code>Network</code>接口返回的值，<code>Request</code>的 <code>parseNetworkResponse(…)</code>参数，是 Volley 中用于内部 Response 转换的核心类。</p>
</blockquote>
<p>封装了网络请求响应的 StatusCode，Headers 和 Body 等。</p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p><code>int statusCode</code> Http 响应状态码<br><code>byte[] data</code> Body 数据<br><code>Map&lt;String, String&gt; headers</code> 响应 Headers<br><code>boolean notModified</code> 表示是否为 304 响应<br><code>long networkTimeMs</code> 请求耗时</p>
<h5 id="内部-Response-转换流程图"><a href="#内部-Response-转换流程图" class="headerlink" title="内部 Response 转换流程图"></a>内部 Response 转换流程图</h5><p><img src="http://ww1.sinaimg.cn/large/7669bef3gw1f00b880kdij20kb0frjt6.jpg" alt="volley response"></p>
<h4 id="CacheDispatcher"><a href="#CacheDispatcher" class="headerlink" title="CacheDispatcher"></a>CacheDispatcher</h4><blockquote>
<p>Provides a thread for performing cache triage on a queue of requests.</p>
</blockquote>
<p>CacheDispatcher类是一个线程类，里面有四个比较重要的变量：<br>1、<code>BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue</code>来自缓存的队列。<br>2、<code>BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code>将会访问网络的队列。<br>3、<code>Cache mCache</code>缓存的处理类。<br>4、<code>ResponseDelivery mDelivery</code>回调响应的类。</p>
<h5 id="CacheDispatcher-run"><a href="#CacheDispatcher-run" class="headerlink" title="CacheDispatcher.run()"></a>CacheDispatcher.run()</h5><p>在线程被创建后马上就被执行了。里面首先会对缓存路径进行初始化工作。接着就进入一个无限的循环等待里。</p>
<p>首先会从缓存队列出取出请求，如果队列为空则会一直阻塞直到队列有数据，接着尝试从缓存当中取出响应结果，如何为空的话则把这条请求加入到网络请求队列中，如果不为空的话再判断该缓存是否已过期，如果已经过期了则同样把这条请求加入到网络请求队列中，否则就认为不需要重发网络请求，直接使用缓存中的数据即可。之后会调用Request的parseNetworkResponse()方法来对数据进行解析，最后就是将解析出来的数据进行回调了。</p>
<h5 id="CacheDispatcher-流程图"><a href="#CacheDispatcher-流程图" class="headerlink" title="CacheDispatcher 流程图"></a>CacheDispatcher 流程图</h5><p><img src="http://ww2.sinaimg.cn/large/7669bef3gw1f00b3tru6mj20qo0k0taw.jpg" alt="NetworkDispatcher"></p>
<h4 id="NetworkDispatcher"><a href="#NetworkDispatcher" class="headerlink" title="NetworkDispatcher"></a>NetworkDispatcher</h4><blockquote>
<p>Provides a thread for performing network dispatch from a queue of requests.</p>
</blockquote>
<p>NetworkDispatcher类是一个线程类，里面有四个比较重要的变量：<br>1、BlockingQueue<request<?>&gt; mQueue响应来自服务的队列。<br>2、Network mNetwork 网络进度请求。<br>3、Cache mCache缓存的处理类。<br>4、ResponseDelivery mDelivery回调响应的类。</request<?></p>
<h5 id="NetworkDispatcher-run"><a href="#NetworkDispatcher-run" class="headerlink" title="NetworkDispatcher.run()"></a>NetworkDispatcher.run()</h5><p>在线程被创建后马上就被执行了。首先进入一个无限的循环等待里。等待任务进来。</p>
<p>在接受到请求后会直接访问网络发送请求，请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。</p>
<h5 id="NetworkDispatcher-流程图"><a href="#NetworkDispatcher-流程图" class="headerlink" title="NetworkDispatcher 流程图"></a>NetworkDispatcher 流程图</h5><p><img src="http://ww4.sinaimg.cn/large/7669bef3gw1f00b3up95qj20qo0k0ac5.jpg" alt="NetworkDispatcher"></p>
<h4 id="ResponseDelivery"><a href="#ResponseDelivery" class="headerlink" title="ResponseDelivery"></a>ResponseDelivery</h4><blockquote>
<p>一个返回结果的分发接口。</p>
</blockquote>
<p>有三个分发接口：<br>1、解析一个从网络或缓存的响应并分发。<br><code>postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response);</code><br>2、解析一个从网络或缓存的响应并分发。提供的运行将会在分发后被执行。<br><code>postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable);</code><br>3、推送一个收到的错误。<br><code>postError(Request&lt;?&gt; request, VolleyError error);</code></p>
<h4 id="RetryPolicy"><a href="#RetryPolicy" class="headerlink" title="RetryPolicy"></a>RetryPolicy</h4><blockquote>
<p>Retry policy for a request.</p>
</blockquote>
<p><code>void retry(VolleyError error) throws VolleyError</code><br>确定是否重试，参数为这次异常的具体信息。在请求异常时此接口会被调用，可在此函数实现中抛出传入的异常表示停止重试。</p>
<h4 id="DefaultRetryPolicy"><a href="#DefaultRetryPolicy" class="headerlink" title="DefaultRetryPolicy"></a>DefaultRetryPolicy</h4><blockquote>
<p>Default retry policy for requests.</p>
</blockquote>
<p>实现 RetryPolicy，Volley 默认的重试策略实现类。主要通过在 retry(…) 函数中判断重试次数是否达到上限确定是否继续重试。<br>其中mCurrentRetryCount变量表示已经重试次数。<br>mBackoffMultiplier表示每次重试之前的 timeout 该乘以的因子。<br>mCurrentTimeoutMs变量表示当前重试的 timeout 时间，会以mBackoffMultiplier作为因子累计前几次重试的 timeout。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/Android-浅析-Volley-二-原理/" data-id="civ9405s70011akqtvwomuo2m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开源库/">开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-Volley-一-使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/Android-浅析-Volley-一-使用/" class="article-date">
  <time datetime="2016-09-21T10:24:19.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/Android-浅析-Volley-一-使用/">Android 浅析 Volley (一) 使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p><strong>Volley is an HTTP library</strong> that makes networking for Android apps easier and most importantly, faster.<br>Volley excels at RPC-type operations used to populate a UI, such as fetching a page of search results as structured data. It integrates easily with any protocol and comes out of the box with support for raw strings, images, and JSON. By providing built-in support for the features you need, Volley frees you from writing boilerplate code and allows you to concentrate on the logic that is specific to your app.</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h3><h4 id="Step-1-创建RequestQueue队列"><a href="#Step-1-创建RequestQueue队列" class="headerlink" title="Step 1.创建RequestQueue队列"></a>Step 1.创建RequestQueue队列</h4><p><code>RequestQueue mQueue = Volley.newRequestQueue(this);</code><br>通过<code>newRequestQueue</code>创建一个新的RequestQueue队列。</p>
<h4 id="Step-2-创建StringRequest对象"><a href="#Step-2-创建StringRequest对象" class="headerlink" title="Step 2.创建StringRequest对象"></a>Step 2.创建StringRequest对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">StringRequest stringRequest = <span class="keyword">new</span> StringRequest(</div><div class="line">    <span class="string">"http://www.baidu.com"</span>,</div><div class="line">    <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">            Log.d(<span class="string">"TAG"</span>, response);</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">            Log.e(<span class="string">"TAG"</span>, error.getMessage(), error);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这里可以看到StringRequest有三个默认参数，第一个是目标的Url，第二个是设置一个回调，第三个是监听错误回调的。</p>
<h4 id="Step-3-将quest对象添加到队列里"><a href="#Step-3-将quest对象添加到队列里" class="headerlink" title="Step 3.将quest对象添加到队列里"></a>Step 3.将quest对象添加到队列里</h4><p><code>mQueue.add(stringRequest);</code><br>最后就是将StringRequest对象往StringRequest里面扔就行了。</p>
<h3 id="图片请求"><a href="#图片请求" class="headerlink" title="图片请求"></a>图片请求</h3><h4 id="Step-1-创建RequestQueue对象"><a href="#Step-1-创建RequestQueue对象" class="headerlink" title="Step 1.创建RequestQueue对象"></a>Step 1.创建RequestQueue对象</h4><p><code>RequestQueue mQueue = Volley.newRequestQueue(this);</code><br>通过<code>newRequestQueue</code>创建一个新的RequestQueue队列。</p>
<h4 id="Step-2-创建ImageRequest对象"><a href="#Step-2-创建ImageRequest对象" class="headerlink" title="Step 2.创建ImageRequest对象"></a>Step 2.创建ImageRequest对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mImageView = (ImageView) findViewById(R.id.imageView);</div><div class="line">ImageRequest imageRequest = <span class="keyword">new</span> ImageRequest(</div><div class="line">    <span class="string">"http://app.sjk.ijinshan.com/market/img/zs/2300841/20150805140347461.png"</span>,</div><div class="line">    <span class="keyword">new</span> Response.Listener&lt;Bitmap&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Bitmap response)</span> </span>&#123;</div><div class="line">            mImageView.setImageBitmap(response);</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">0</span>, <span class="number">0</span>, </div><div class="line">    Config.RGB_565, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">            mImageView.setImageResource(R.drawable.default_image);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>ImageRequest的构造函数接收六个参数，第一个参数就是图片的URL地址。第二个参数是图片请求成功的回调，这里我们把返回的Bitmap参数设置到ImageView中。第三第四个参数分别用于指定允许图片最大的宽度和高度，如果指定的网络图片的宽度或高度大于这里的最大值，则会对图片进行压缩，指定成0的话就表示不管图片有多大，都不会进行压缩。第五个参数用于指定图片的颜色属性，Bitmap.Config下的几个常量都可以在这里使用，其中ARGB_8888可以展示最好的颜色属性，每个图片像素占据4个字节的大小，而RGB_565则表示每个图片像素占据2个字节大小。第六个参数是图片请求失败的回调，这里我们当请求失败时在ImageView中显示一张默认图片。</p>
<h4 id="Step-3-将quest对象添加到队列里-1"><a href="#Step-3-将quest对象添加到队列里-1" class="headerlink" title="Step 3.将quest对象添加到队列里"></a>Step 3.将quest对象添加到队列里</h4><p><code>mQueue.add(stringRequest);</code><br>最后就是将StringRequest对象往StringRequest里面扔就行了。</p>
<h3 id="自定义Quest请求"><a href="#自定义Quest请求" class="headerlink" title="自定义Quest请求"></a>自定义Quest请求</h3><h4 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h4><p>自定义的请求其实很简单，首先是继承父类Request<t>，然后重载其中两个函数<code>parseNetworkResponse(NetworkResponse response)</code>,<code>deliverResponse(XmlPullParser response)</code>。就可以像用StringResponse那样去使用了。</t></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Volley总体来说非常好用和方便，封装好了各种网络请求，特别是底层支持对开发者来说免除了很多烦恼，还可以定制自己的Response。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/Android-浅析-Volley-一-使用/" data-id="civ9405s7000zakqta2kbyxxw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开源库/">开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-EventBus-二-原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/Android-浅析-EventBus-二-原理/" class="article-date">
  <time datetime="2016-09-21T04:14:51.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/Android-浅析-EventBus-二-原理/">Android 浅析 EventBus (二) 原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>本次分析从两个方向深入，一个是从注册开始，一个是从发送消息开始。从这两个方向就能大致了解eventbus的运作原理。</p>
<h2 id="注册原理"><a href="#注册原理" class="headerlink" title="注册原理"></a>注册原理</h2><p><img src="http://ww3.sinaimg.cn/large/7669bef3gw1ez8jqclk6dj20ds0jdacb.jpg" alt="register"></p>
<h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><p><code>EventBus.getDefault().register(this);</code><br>EventBus的注册就从这里开始。</p>
<h3 id="Step-1-EventBus-getDefault"><a href="#Step-1-EventBus-getDefault" class="headerlink" title="Step 1.EventBus.getDefault()"></a>Step 1.EventBus.getDefault()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">            <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> defaultInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一句很典型的单例写法，整个eventbus在项目中是以单例的形式出现的。在初始化这块调用的是EventBusBuilder的默认参数。这也是Builder模式比较常用的。</p>
<h3 id="Step-2-EventBus-register-Object-subscriber"><a href="#Step-2-EventBus-register-Object-subscriber" class="headerlink" title="Step 2.EventBus.register(Object subscriber)"></a>Step 2.EventBus.register(Object subscriber)</h3><p>这里是注册订阅者的地方，同样的注册方式有这么几个：</p>
<ol>
<li>register(Object subscriber)</li>
<li>register(Object subscriber, int priority)</li>
<li>registerSticky(Object subscriber)</li>
<li>registerSticky(Object subscriber, int priority)<br>它们之间最主要的区别就是参数的不同。在实现上它们都是调用<code>void register(Object subscriber, boolean sticky, int priority)</code>函数实现的。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());</div><div class="line">    <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">        subscribe(subscriber, subscriberMethod, sticky, priority);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里首先调用<code>findSubscriberMethods()</code>方法根据当前订阅者的类名查找到该类的所有订阅者函数。</p>
<p>在获取完所有订阅者函数后调用subscribe方法。</p>
<h3 id="Step-3-EventBus-subscribe-subscriber-subscriberMethod-…"><a href="#Step-3-EventBus-subscribe-subscriber-subscriberMethod-…" class="headerlink" title="Step 3.EventBus.subscribe(subscriber, subscriberMethod, …)"></a>Step 3.EventBus.subscribe(subscriber, subscriberMethod, …)</h3><p>这里是注册函数的核心，分成三个部分：</p>
<ol>
<li>通过<code>subscriptionsByEventType</code>得到这个Event类型所有订阅者信息队列，然后根据优先级将当前订阅者信息插入到队列里面。</li>
<li>在<code>typesBySubscriber</code>中得到当前订阅者订阅的所有事件队列，将此事件保存到队列中，用于后续取消订阅。</li>
<li>检查这个事件是否是 Sticky 事件，如果是则从stickyEvents事件保存队列中取出该事件类型最后一个事件发送给当前订阅者。</li>
</ol>
<h3 id="Step-4-EventBus-unregister-Object-subscriber"><a href="#Step-4-EventBus-unregister-Object-subscriber" class="headerlink" title="Step 4.EventBus.unregister(Object subscriber)"></a>Step 4.EventBus.unregister(Object subscriber)</h3><p>最后就是反注册，这里就比较简单了。<br>首先从<code>typesBySubscriber</code>获取当前订阅者，然后找到此订阅者的所有类型，将此订阅者的所有类型从<code>subscriptionsByEventType</code>表里删除。接着再把此订阅者从<code>typesBySubscriber</code>中删除。</p>
<h2 id="发送原理"><a href="#发送原理" class="headerlink" title="发送原理"></a>发送原理</h2><p><img src="http://ww3.sinaimg.cn/large/7669bef3gw1ez8k256zbnj20rg148n24.jpg" alt="post"></p>
<h3 id="MainActivity-1"><a href="#MainActivity-1" class="headerlink" title="MainActivity"></a>MainActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String message;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageEvent</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(MessageEvent event)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(<span class="string">"hello eventbus"</span>));</div></pre></td></tr></table></figure>
<p><code>EventBus.getDefault().post(this);</code><br>EventBus的注册就从这里开始。其实这个就是一个序列化和反序列化的过程。将一段event打包然后再接受函数解包。</p>
<h3 id="EventBus-post-Object-event"><a href="#EventBus-post-Object-event" class="headerlink" title="EventBus.post(Object event)"></a>EventBus.post(Object event)</h3><p>这个函数将收到的event发送到event bus。<br>首先将此事件保存到<code>currentPostingThreadState</code>的事件队列里。</p>
<p>然后查看当前是否有事件在发送，然后调用<code>postSingleEvent()</code>函数发送。</p>
<h3 id="EventBus-postSingleEvent"><a href="#EventBus-postSingleEvent" class="headerlink" title="EventBus.postSingleEvent()"></a>EventBus.postSingleEvent()</h3><p>首先调用<code>lookupAllEventTypes()</code>获取所有事件的类型，然后循环调用<code>postSingleEventForEventType()</code>函数发送事件。</p>
<h3 id="EventBus-lookupAllEventTypes-…"><a href="#EventBus-lookupAllEventTypes-…" class="headerlink" title="EventBus.lookupAllEventTypes(…)"></a>EventBus.lookupAllEventTypes(…)</h3><p>这里从当前事件中获取父类和接口，一直往上循环获取直到最后。然后保存到<code>eventTypesCache</code>变量里。</p>
<h3 id="EventBus-postSingleEventForEventType-…"><a href="#EventBus-postSingleEventForEventType-…" class="headerlink" title="EventBus.postSingleEventForEventType(…)"></a>EventBus.postSingleEventForEventType(…)</h3><p>这里就是获取每个事件，然后通过循环发送这些事件，会将事件的参数添加到<code>PostingThreadState</code>结构体里传到<code>postToSubscription()</code>函数来发送，这里就能区分是主界面线程还是非界面线程。最后再把参数都反初始化。</p>
<h3 id="EventBus-postToSubscription-Subscription-subscription-…"><a href="#EventBus-postToSubscription-Subscription-subscription-…" class="headerlink" title="EventBus.postToSubscription(Subscription subscription, …)"></a>EventBus.postToSubscription(Subscription subscription, …)</h3><p>这个函数就是主要的分发函数，根据每个事件的threadMode来分发到各自相应的回调函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">    <span class="keyword">case</span> PostThread:</div><div class="line">    <span class="keyword">case</span> MainThread:</div><div class="line">    <span class="keyword">case</span> BackgroundThread:</div><div class="line">    <span class="keyword">case</span> Async:</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要就是分发到四个不同函数。</p>
<ol>
<li>invokeSubscriber()</li>
<li>mainThreadPoster.enqueue()</li>
<li>backgroundPoster.enqueue()</li>
<li>asyncPoster.enqueue()</li>
</ol>
<p>这里我们分别看下：</p>
<ol>
<li>PostThread：默认的 ThreadMode，表示在执行 Post    操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI    线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若Post线程为主线程，不能耗时的操作；</li>
<li>MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作；</li>
<li>BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里；</li>
<li>Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。</li>
</ol>
<p>这里我们可以看到从最开始eventbus就通过反射将需要调用的函数加载到eventbus的类里保存下来了。不过这里也可以知道其实eventbus也只是通过handler来调用主界面的线程。秘密揭开了，自己也可以尝试写一套。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/Android-浅析-EventBus-二-原理/" data-id="civ9405s7000oakqthstf8hbv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EventBus/">EventBus</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开源库/">开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-EventBus-一-使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/Android-浅析-EventBus-一-使用/" class="article-date">
  <time datetime="2016-09-21T04:01:57.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/Android-浅析-EventBus-一-使用/">Android 浅析 EventBus (一) 使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>EventBus is a publish/subscribe event bus optimized for Android.<br>EventBus 是一个为 Android 优化的 publish/subscribe 事件总线。</p>
</blockquote>
<ol>
<li>简化组件间的通讯。</li>
<li>事件发送者和接收者解耦。</li>
<li>很好地执行活动，片段和背景线程，避免复杂和容易出错的依赖关系和生命周期的问题，使您的代码更简单</li>
<li>快速</li>
<li>小（大约50K）</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Step-1-定义事件"><a href="#Step-1-定义事件" class="headerlink" title="Step 1: 定义事件"></a>Step 1: 定义事件</h3><p>Events are POJO (plain old Java object) without any specific requirements.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String message;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageEvent</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.message = message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Step-2-准备订阅者"><a href="#Step-2-准备订阅者" class="headerlink" title="Step 2: 准备订阅者"></a>Step 2: 准备订阅者</h3><p>订阅者要实现一个接口函数<code>onEvent</code>，用来在收到通知后作出响应。这需要注册到EventBus里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">    EventBus.getDefault().unregister(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">super</span>.onStop();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// This method will be called when a MessageEvent is posted</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MessageEvent event)</span></span>&#123;&#125;</div><div class="line">    </div><div class="line"><span class="comment">// This method will be called when a SomeOtherEvent is posted public void onEvent(SomeOtherEvent event)&#123;&#125;</span></div></pre></td></tr></table></figure></p>
<h3 id="Step-3-发送通知"><a href="#Step-3-发送通知" class="headerlink" title="Step 3: 发送通知"></a>Step 3: 发送通知</h3><p>发送通知可以在代码的任意一个地方。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(<span class="string">"Hello everyone!"</span>));</div></pre></td></tr></table></figure></p>
<h2 id="主要类解析"><a href="#主要类解析" class="headerlink" title="主要类解析"></a>主要类解析</h2><p><img src="http://ww2.sinaimg.cn/large/7669bef3gw1eyux5ozpdkj20lp0mjdie.jpg" alt="主要类图"></p>
<h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><blockquote>
<p>EventBus is a central publish/subscribe event system for Android. Events are posted (post(Object)) to the bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events, subscribers must register themselves to the bus using register(Object). Once registered, subscribers receive events until unregister(Object) is called. By convention, event handling methods must be named “onEvent”, be public, return nothing (void), and have exactly one parameter (the event).<br>EventBus的介绍本身就很清楚了。它是一个Android的发布/订阅事件系统。</p>
</blockquote>
<p>EventBus 类负责所有对外暴露的 API，其中的 register()、post()、unregister() 函数配合上自定义的 EventType 及事件响应函数即可完成核心功能。</p>
<p>EventBus可以通过getDefault来获取单例，也可以自己通过创建或者EventBusBuilder来新建一个，不过EventBus是相互隔离的。huo zh</p>
<h4 id="getDefault"><a href="#getDefault" class="headerlink" title="getDefault()"></a>getDefault()</h4><blockquote>
<p>进程中创建一个EventBus的单例返回。</p>
</blockquote>
<h4 id="register-Object-subscriber"><a href="#register-Object-subscriber" class="headerlink" title="register(Object subscriber)"></a>register(Object subscriber)</h4><blockquote>
<p>注册一个订阅者到接收事件。订阅者必须调用’unregister()’当它们不再接收事件。</p>
</blockquote>
<p>订阅者有一个事件句柄方法用他们的名字识别，通常是叫“onEvent”。事件句柄方法必须有一个参数，事件。如果事件句柄方法被调用在一个特殊的线程，一个修改将被用到方法的名字上。有效的修改符合ThreadMode枚举之一。例如，如果一个方法被调用在由EventBus在UI/主线程，这将被称为“onEventMainThread”。</p>
<h4 id="unregister-Object-subscriber"><a href="#unregister-Object-subscriber" class="headerlink" title="unregister(Object subscriber)"></a>unregister(Object subscriber)</h4><blockquote>
<p>反注册一个订阅者</p>
</blockquote>
<h4 id="post-Object-event"><a href="#post-Object-event" class="headerlink" title="post(Object event)"></a>post(Object event)</h4><blockquote>
<p>发送一个事件到event bus。</p>
</blockquote>
<h4 id="四种订阅函数"><a href="#四种订阅函数" class="headerlink" title="四种订阅函数"></a>四种订阅函数</h4><ol>
<li>onEvent:如果使用onEvent作为订阅函数，那么该事件在哪个线程发布出来的，onEvent就会在这个线程中运行，也就是说发布事件和接收事件线程在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。</li>
<li>onEventMainThread:如果使用onEventMainThread作为订阅函数，那么不论事件是在哪个线程中发布出来的，onEventMainThread都会在UI线程中执行，接收事件就会在UI线程中运行，这个在Android中是非常有用的，因为在Android中只能在UI线程中跟新UI，所以在onEvnetMainThread方法中是不能执行耗时操作的。</li>
<li>onEvnetBackground:如果使用onEventBackgrond作为订阅函数，那么如果事件是在UI线程中发布出来的，那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么onEventBackground函数直接在该子线程中执行。</li>
<li>onEventAsync：使用这个函数作为订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync.</li>
</ol>
<h3 id="EventBusBuilder"><a href="#EventBusBuilder" class="headerlink" title="EventBusBuilder"></a>EventBusBuilder</h3><blockquote>
<p>Creates EventBus instances with custom parameters and also allows to install a custom default EventBus instance.</p>
</blockquote>
<p>Builder对应的就是Builder生成器模式。EventBusBuilder用于在需要设置参数过多时构造 EventBus。包含的属性也是 EventBus 的一些设置参数。</p>
<h4 id="build"><a href="#build" class="headerlink" title="build()"></a>build()</h4><blockquote>
<p>生成一个EventBus基于现有的配置。</p>
</blockquote>
<h3 id="SubscriberMethod"><a href="#SubscriberMethod" class="headerlink" title="SubscriberMethod"></a>SubscriberMethod</h3><blockquote>
<p>订阅者事件响应函数信息，包括响应方法、线程 Mode、事件类型以及一个用来比较 SubscriberMethod 是否相等的特征值 methodString 共四个变量</p>
</blockquote>
<p>其中 methodString 为 ${methodClassName}#${methodName}(${eventTypeClassName}。</p>
<h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><blockquote>
<p>订阅者信息，包括 subscriber 对象、事件响应方法 SubscriberMethod、优先级 priority。</p>
</blockquote>
<h3 id="HandlerPoster"><a href="#HandlerPoster" class="headerlink" title="HandlerPoster"></a>HandlerPoster</h3><blockquote>
<p>事件主线程处理，对应ThreadMode.MainThread。继承自 Handler，enqueue 函数将事件放到队列中，并利用 handler 发送 message，handleMessage 函数从队列中取事件，invoke 事件响应函数处理。</p>
</blockquote>
<h3 id="AsyncPoster"><a href="#AsyncPoster" class="headerlink" title="AsyncPoster"></a>AsyncPoster</h3><blockquote>
<p>事件异步线程处理，对应ThreadMode.Async，继承自 Runnable。enqueue 函数将事件放到队列中，并调用线程池执行当前任务，在 run 函数从队列中取事件，invoke 事件响应函数处理。</p>
</blockquote>
<h3 id="BackgroundPoster"><a href="#BackgroundPoster" class="headerlink" title="BackgroundPoster"></a>BackgroundPoster</h3><blockquote>
<p>事件 Background 处理，对应ThreadMode.BackgroundThread，继承自 Runnable。enqueue 函数将事件放到队列中，并调用线程池执行当前任务，在 run 函数从队列中取事件，invoke 事件响应函数处理。</p>
</blockquote>
<p>与 AsyncPoster.java 不同的是，BackgroundPoster 中的任务只在同一个线程中依次执行，而不是并发执行。</p>
<h3 id="PendingPost"><a href="#PendingPost" class="headerlink" title="PendingPost"></a>PendingPost</h3><blockquote>
<p>订阅者和事件信息实体类，并含有同一队列中指向下一个对象的指针。通过缓存存储不用的对象，减少下次创建的性能消耗。</p>
</blockquote>
<h3 id="PendingPostQueue"><a href="#PendingPostQueue" class="headerlink" title="PendingPostQueue"></a>PendingPostQueue</h3><blockquote>
<p>通过 head 和 tail 指针维护一个PendingPost队列。HandlerPoster、AsyncPoster、BackgroundPoster 都包含一个此队列实例，表示各自的订阅者及事件信息队列，在事件到来时进入队列，处理时从队列中取出一个元素进行处理。</p>
</blockquote>
<h3 id="NoSubscriberEvent"><a href="#NoSubscriberEvent" class="headerlink" title="NoSubscriberEvent"></a>NoSubscriberEvent</h3><blockquote>
<p>当没有事件处理函数对事件处理时发送的 EventBus 内部自定义事件，通过 post 发送，订阅者可自行订阅这类事件进行处理。</p>
</blockquote>
<h3 id="ThreadMode"><a href="#ThreadMode" class="headerlink" title="ThreadMode"></a>ThreadMode</h3><blockquote>
<p>线程 Mode 枚举类，表示事件响应函数执行线程信息</p>
</blockquote>
<p>包括:<br>1.ThreadMode.PostThread<br>2.ThreadMode.MainThread<br>3.ThreadMode.BackgroundThread<br>4.ThreadMode.Async</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/Android-浅析-EventBus-一-使用/" data-id="civ9405s7000pakqtc74p4bum" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EventBus/">EventBus</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开源库/">开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/FreeLoad/">FreeLoad</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ashmem/">Ashmem</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder/">Binder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Broadcast/">Broadcast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ButterKnife/">ButterKnife</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ContentProvider/">ContentProvider</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EventBus/">EventBus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FreeLoad/">FreeLoad</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SharedPreferences/">SharedPreferences</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源库/">开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/智能指针/">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注解/">注解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-基础知识/" style="font-size: 18.33px;">Android_基础知识</a> <a href="/tags/Ashmem/" style="font-size: 10px;">Ashmem</a> <a href="/tags/Binder/" style="font-size: 13.33px;">Binder</a> <a href="/tags/Broadcast/" style="font-size: 13.33px;">Broadcast</a> <a href="/tags/ButterKnife/" style="font-size: 11.67px;">ButterKnife</a> <a href="/tags/ContentProvider/" style="font-size: 15px;">ContentProvider</a> <a href="/tags/EventBus/" style="font-size: 11.67px;">EventBus</a> <a href="/tags/FreeLoad/" style="font-size: 10px;">FreeLoad</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/RxJava/" style="font-size: 11.67px;">RxJava</a> <a href="/tags/SharedPreferences/" style="font-size: 11.67px;">SharedPreferences</a> <a href="/tags/Volley/" style="font-size: 11.67px;">Volley</a> <a href="/tags/开源库/" style="font-size: 16.67px;">开源库</a> <a href="/tags/智能指针/" style="font-size: 10px;">智能指针</a> <a href="/tags/注解/" style="font-size: 10px;">注解</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/08/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/09/22/Android-浅析-RxJava-二-原理/">Android 浅析 RxJava (二) 原理</a>
          </li>
        
          <li>
            <a href="/2016/09/22/Android-浅析-RxJava-一-使用/">Android 浅析 RxJava (一) 使用</a>
          </li>
        
          <li>
            <a href="/2016/09/21/Java-注解-Dependency-injection/">Java 注解 Dependency injection</a>
          </li>
        
          <li>
            <a href="/2016/09/21/Android-浅析-ButterKnife-二-源码解析/">Android 浅析 ButterKnife (二) 源码解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>