<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Android 浅析 Broadcast (三) 发送原理 | Zhong&#39;s_blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Android,Android_基础知识,Broadcast," />
  

  <meta name="description" content="Android Broadcast 是 android 四大组件之一，为应用程序提供在组件之间传播数据（Intent）的一种机制。上一章从注册的角度来了解了 Broadcast 的注册机制，本章将从发送的角度来探讨一个广播的是如何发送并且让接收方接收的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 浅析 Broadcast (三) 发送原理">
<meta property="og:url" content="http://yoursite.com/2016/09/18/Android-浅析-Broadcast-三-发送原理/index.html">
<meta property="og:site_name" content="Zhong's_blog">
<meta property="og:description" content="Android Broadcast 是 android 四大组件之一，为应用程序提供在组件之间传播数据（Intent）的一种机制。上一章从注册的角度来了解了 Broadcast 的注册机制，本章将从发送的角度来探讨一个广播的是如何发送并且让接收方接收的。">
<meta property="og:image" content="http://ww3.sinaimg.cn/large/7669bef3gw1eykjfyq6xej21kw0izwh4.jpg">
<meta property="og:updated_time" content="2016-09-22T08:02:09.757Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 浅析 Broadcast (三) 发送原理">
<meta name="twitter:description" content="Android Broadcast 是 android 四大组件之一，为应用程序提供在组件之间传播数据（Intent）的一种机制。上一章从注册的角度来了解了 Broadcast 的注册机制，本章将从发送的角度来探讨一个广播的是如何发送并且让接收方接收的。">
<meta name="twitter:image" content="http://ww3.sinaimg.cn/large/7669bef3gw1eykjfyq6xej21kw0izwh4.jpg">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=028c63b1" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">Tag</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">Tag</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            Blog
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            Category
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            Tag
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            About
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概括"><span class="toc-text">概括</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送过程"><span class="toc-text">发送过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-1-ContextWrapper-sendBroadcast"><span class="toc-text">Step 1.ContextWrapper.sendBroadcast()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-2-ContextImpl-sendBroadcast"><span class="toc-text">Step 2.ContextImpl.sendBroadcast()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-3-ActivityManagerNative-broadcastIntent"><span class="toc-text">Step 3.ActivityManagerNative.broadcastIntent()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-4-ActivityManagerService-broadcastIntent"><span class="toc-text">Step 4.ActivityManagerService.broadcastIntent()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-5-ActivityManagerService-broadcastIntentLocked"><span class="toc-text">Step 5.ActivityManagerService.broadcastIntentLocked()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Part-1："><span class="toc-text">Part 1：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part-2："><span class="toc-text">Part 2：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part-3："><span class="toc-text">Part 3：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-6-BroadcastQueue-scheduleBroadcastsLocked"><span class="toc-text">Step 6.BroadcastQueue.scheduleBroadcastsLocked()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-7-BroadcastQueue-handleMessage"><span class="toc-text">Step 7.BroadcastQueue.handleMessage()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-8-BroadcastQueue-processNextBroadcast"><span class="toc-text">Step 8.BroadcastQueue.processNextBroadcast()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-9-BroadcastQueue-deliverToRegisteredReceiverLocked"><span class="toc-text">Step 9.BroadcastQueue.deliverToRegisteredReceiverLocked()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-10-BroadcastQueue-performReceiveLocked"><span class="toc-text">Step 10.BroadcastQueue.performReceiveLocked()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-11-ApplicationThreadNative-scheduleRegisteredReceiver"><span class="toc-text">Step 11.ApplicationThreadNative.scheduleRegisteredReceiver()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-12-ApplicationThread-scheduleRegisteredReceiver"><span class="toc-text">Step 12.ApplicationThread.scheduleRegisteredReceiver()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-13-LoadedApk-ReceiverDispatcher-InnerReceiver-performReceive"><span class="toc-text">Step 13.LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-14-LoadedApk-ReceiverDispatcher-performReceive"><span class="toc-text">Step 14.LoadedApk.ReceiverDispatcher.performReceive()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-15-Hanlder-post"><span class="toc-text">Step 15.Hanlder.post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-16-LoadedApk-ReceiverDispatcher-Args-run"><span class="toc-text">Step 16.LoadedApk.ReceiverDispatcher.Args.run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-17-BroadcastReceiver-onReceive"><span class="toc-text">Step 17.BroadcastReceiver.onReceive</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Android-浅析-Broadcast-三-发送原理" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Android 浅析 Broadcast (三) 发送原理</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.09.18</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>钟华健</span>
        </span>
      

      


      
        <span>
          <i class="icon-comment"></i>
          <a href="https://github.com/jasonzhong/2016/09/18/Android-浅析-Broadcast-三-发送原理/#disqus_thread"></a>
        </span>
      

    </div>
  </header>

  <div class="article-content">
    
      <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>Broadcast的发送是以AMS为中心，通过AMS的分发将消息分发到对应的接收器中。并且这个过程是通过IPC Binder 来完成的。</p>
</blockquote>
<p>发送流程图<br><img src="http://ww3.sinaimg.cn/large/7669bef3gw1eykjfyq6xej21kw0izwh4.jpg" alt="发送流程"></p>
<h2 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h2><h3 id="Step-1-ContextWrapper-sendBroadcast"><a href="#Step-1-ContextWrapper-sendBroadcast" class="headerlink" title="Step 1.ContextWrapper.sendBroadcast()"></a>Step 1.ContextWrapper.sendBroadcast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"..."</span>);</div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure>
<p>这是第一步，发送广播的操作非常简单，生成一个Intent，然后调用sendBroadcast发送就可以了。ContextWrapper的调用其实是一个代理类，实际调用是在ContextImpl。</p>
<h3 id="Step-2-ContextImpl-sendBroadcast"><a href="#Step-2-ContextImpl-sendBroadcast" class="headerlink" title="Step 2.ContextImpl.sendBroadcast()"></a>Step 2.ContextImpl.sendBroadcast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">intent.prepareToLeaveProcess();</div><div class="line">ActivityManagerNative.getDefault().broadcastIntent(...);</div></pre></td></tr></table></figure>
<p>在ContextImpl才是发送广播的起点，首先Intent会调用prepareToLeaveProcess()准备离开现有进程，然后调用AMS的broadcastIntent()开始发送过程。</p>
<h3 id="Step-3-ActivityManagerNative-broadcastIntent"><a href="#Step-3-ActivityManagerNative-broadcastIntent" class="headerlink" title="Step 3.ActivityManagerNative.broadcastIntent()"></a>Step 3.ActivityManagerNative.broadcastIntent()</h3><p>这个类就是一个代理，这个函数的职责很简单，将传过来的参数打包到Parcel，然后通过<strong>Binder</strong>将数据传到AMS里。</p>
<h3 id="Step-4-ActivityManagerService-broadcastIntent"><a href="#Step-4-ActivityManagerService-broadcastIntent" class="headerlink" title="Step 4.ActivityManagerService.broadcastIntent()"></a>Step 4.ActivityManagerService.broadcastIntent()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> res = broadcastIntentLocked(...)</div></pre></td></tr></table></figure>
<p>此函数就是解析一下传进来的数据，然后调用AMS的broadcastIntentLocked进行下一步。</p>
<h3 id="Step-5-ActivityManagerService-broadcastIntentLocked"><a href="#Step-5-ActivityManagerService-broadcastIntentLocked" class="headerlink" title="Step 5.ActivityManagerService.broadcastIntentLocked()"></a>Step 5.ActivityManagerService.broadcastIntentLocked()</h3><p>这个函数比较长，我们一段一段来看。</p>
<h4 id="Part-1："><a href="#Part-1：" class="headerlink" title="Part 1："></a>Part 1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">intent = <span class="keyword">new</span> Intent(intent);</div><div class="line">...</div><div class="line"><span class="comment">// Figure out who all will receive this broadcast.</span></div><div class="line">List receivers = <span class="keyword">null</span>;</div><div class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (...) &#123;</div><div class="line">    registeredReceivers = mReceiverResolver.queryIntent(intent,...);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    registeredReceivers = mReceiverResolver.queryIntent(intent,...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一段是根据Intent的值找出相应接受的广播接收器。因为AMS会把注册的广播接收器保存到mReceiverResolver变量里。</p>
<h4 id="Part-2："><a href="#Part-2：" class="headerlink" title="Part 2："></a>Part 2：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> replacePending =  (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>这一段就是判断是否要替换之前的intent。</p>
<h4 id="Part-3："><a href="#Part-3：" class="headerlink" title="Part 3："></a>Part 3：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class="line">BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(...);</div><div class="line">queue.enqueueParallelBroadcastLocked(r);</div><div class="line">queue.scheduleBroadcastsLocked();</div></pre></td></tr></table></figure>
<p>这里首先会通过broadcastQueueForIntent()从AMS的全局变量mFgBroadcastQueue或mBgBroadcastQueue中获取一个队列，里面保存着所有Broadcast对象。然后通过获取的参数新创建一块BroadcastRecord块，将它添加到队列里面去。接下来我们看scheduleBroadcastsLocked()的过程。</p>
<h3 id="Step-6-BroadcastQueue-scheduleBroadcastsLocked"><a href="#Step-6-BroadcastQueue-scheduleBroadcastsLocked" class="headerlink" title="Step 6.BroadcastQueue.scheduleBroadcastsLocked()"></a>Step 6.BroadcastQueue.scheduleBroadcastsLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mBroadcastsScheduled) &#123;<span class="keyword">return</span>;&#125;</div><div class="line">mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</div><div class="line">mBroadcastsScheduled = <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
<p>这里的mBroadcastsScheduled表示AMS当前是不是正在处理其它广播，如果是的话，这里就先不处理直接返回了，保证所有广播串行处理。<br>因为是通过消息的方式来发送，所以广播的发送和处理是异步的。成员变量mHandler是一个AMS内部的BroadcastQueue定义的Handler类变量，把一个空的类型为BROADCAST_INTENT_MSG的消息放到队列里。</p>
<h3 id="Step-7-BroadcastQueue-handleMessage"><a href="#Step-7-BroadcastQueue-handleMessage" class="headerlink" title="Step 7.BroadcastQueue.handleMessage()"></a>Step 7.BroadcastQueue.handleMessage()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BROADCAST_INTENT_MSG：</div><div class="line">    processNextBroadcast(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<p>很简单，又是通过processNextBroadcast()来处理下一条广播。</p>
<h3 id="Step-8-BroadcastQueue-processNextBroadcast"><a href="#Step-8-BroadcastQueue-processNextBroadcast" class="headerlink" title="Step 8.BroadcastQueue.processNextBroadcast()"></a>Step 8.BroadcastQueue.processNextBroadcast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mBroadcastsScheduled = <span class="keyword">false</span>;</div><div class="line">...</div><div class="line"><span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">    r = mParallelBroadcasts.remove(<span class="number">0</span>);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = r.receivers.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">        Object target = r.receivers.get(i);</div><div class="line">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是分发的核心了，首先将mBroadcastsScheduled设为false是让下一条消息能发送，接着循环mParallelBroadcasts的size将里面的广播记录块取出来，因为里面包含了目标target，通过deliverToRegisteredReceiverLocked将它发送给订阅了的接收器。</p>
<h3 id="Step-9-BroadcastQueue-deliverToRegisteredReceiverLocked"><a href="#Step-9-BroadcastQueue-deliverToRegisteredReceiverLocked" class="headerlink" title="Step 9.BroadcastQueue.deliverToRegisteredReceiverLocked()"></a>Step 9.BroadcastQueue.deliverToRegisteredReceiverLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (filter.requiredPermission != <span class="keyword">null</span>) &#123;</div><div class="line">    ...</div><div class="line">    skip = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="keyword">if</span> (!skip) &#123;</div><div class="line">    performReceiveLocked(...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一段做了很多个判断，都是在检查广播发送和接受的权限判断，如果不通过这直接跳过。在通过判断后再调用performReceiveLocked执行发送操作。</p>
<h3 id="Step-10-BroadcastQueue-performReceiveLocked"><a href="#Step-10-BroadcastQueue-performReceiveLocked" class="headerlink" title="Step 10.BroadcastQueue.performReceiveLocked()"></a>Step 10.BroadcastQueue.performReceiveLocked()</h3><p>首先来看下这个函数的参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</div></pre></td></tr></table></figure></p>
<p>这里首先判断通过注册进来的广播是什么，因为例子中是通过activity注册的，这里的app参数就是代表activity的进程记录块，receiver这是注册时传给AMS的Binder对象。<br>在调用后会通过：app.thread.scheduleRegisteredReceiver()函数把广播分发给activity。</p>
<h3 id="Step-11-ApplicationThreadNative-scheduleRegisteredReceiver"><a href="#Step-11-ApplicationThreadNative-scheduleRegisteredReceiver" class="headerlink" title="Step 11.ApplicationThreadNative.scheduleRegisteredReceiver()"></a>Step 11.ApplicationThreadNative.scheduleRegisteredReceiver()</h3><p>这里也很简单，做一个打包通过binder分发而已。</p>
<h3 id="Step-12-ApplicationThread-scheduleRegisteredReceiver"><a href="#Step-12-ApplicationThread-scheduleRegisteredReceiver" class="headerlink" title="Step 12.ApplicationThread.scheduleRegisteredReceiver()"></a>Step 12.ApplicationThread.scheduleRegisteredReceiver()</h3><p>传进来的第一个参数是<strong>IIntentReceiver receiver</strong>，其实际类型是定义在LoadedApk类的内部类ReceiverDispatcher里面的一个内部类InnerReceiver，调用performReceive函数来执行。</p>
<h3 id="Step-13-LoadedApk-ReceiverDispatcher-InnerReceiver-performReceive"><a href="#Step-13-LoadedApk-ReceiverDispatcher-InnerReceiver-performReceive" class="headerlink" title="Step 13.LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive()"></a>Step 13.LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LoadedApk.ReceiverDispatcher rd = mDispatcher.get();</div><div class="line">rd.performReceive();</div></pre></td></tr></table></figure>
<p>这里又是一个转折，调用LoadedApk.ReceiverDispatcher类的performReceive()来执行。</p>
<h3 id="Step-14-LoadedApk-ReceiverDispatcher-performReceive"><a href="#Step-14-LoadedApk-ReceiverDispatcher-performReceive" class="headerlink" title="Step 14.LoadedApk.ReceiverDispatcher.performReceive()"></a>Step 14.LoadedApk.ReceiverDispatcher.performReceive()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Handler mActivityThread;</div><div class="line">...</div><div class="line">Args args = <span class="keyword">new</span> Args()</div><div class="line"><span class="keyword">if</span> (!mActivityThread.post(args)) &#123;&#125;</div></pre></td></tr></table></figure>
<p>在ReceiverDispatcher类里mActivityThread的类型是一个handler，它是前面MainActivity注册广播接收器时，从ActivityThread取得的。这里ReceiverDispatcher借助这个Handler，把这个广播以消息的形式放到MainActivity所在的这个ActivityThread的消息队列中去。<br>而Args是ReceiverDispatcher的一个内部类，继承自Runnable类。</p>
<h3 id="Step-15-Hanlder-post"><a href="#Step-15-Hanlder-post" class="headerlink" title="Step 15.Hanlder.post"></a>Step 15.Hanlder.post</h3><p>post的作用就是把消息放在消息队列中，然后就返回，这个消息最终会在传进来的Runnable类型的参数的run成员函数中进行处理。</p>
<h3 id="Step-16-LoadedApk-ReceiverDispatcher-Args-run"><a href="#Step-16-LoadedApk-ReceiverDispatcher-Args-run" class="headerlink" title="Step 16.LoadedApk.ReceiverDispatcher.Args.run"></a>Step 16.LoadedApk.ReceiverDispatcher.Args.run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</div><div class="line"><span class="keyword">final</span> Intent intent = mCurIntent;</div><div class="line">...</div><div class="line">ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class="line">intent.setExtrasClassLoader(cl);</div><div class="line">setExtrasClassLoader(cl);</div><div class="line">receiver.setPendingResult(<span class="keyword">this</span>);</div><div class="line">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>
<p>mReceiver是ReceiverDispatcher类的成员变量,它就是MainActivity注册广播接收器时创建的BroadcastReceiver实例。<br>在这里就能够通过receiver将广播分发到处理的地方了。</p>
<h3 id="Step-17-BroadcastReceiver-onReceive"><a href="#Step-17-BroadcastReceiver-onReceive" class="headerlink" title="Step 17.BroadcastReceiver.onReceive"></a>Step 17.BroadcastReceiver.onReceive</h3><p>最后就是定义在自己类里的onReceive被调用，整个过程到此结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们将整个过程来总结一下：</p>
<ol>
<li>第一阶段：<br>Step 1 ～ Step 7:通过自己的sendBroadcast把一个广播通过Binder进程间通信机制发送给AMS，AMS根据这个广播的Action类型找到相应的广播接收器，然后把这个广播放进自己的消息队列中去。</li>
<li>第二阶段：<br>Step 8 ～ Step 15:AMS在消息循环中处理这个广播，并通过Binder进程间通信机制把这个广播分发给注册的广播接收分发器ReceiverDispatcher，ReceiverDispatcher把这个广播放进MainActivity所在的线程的消息队列中去。</li>
<li>第三阶段：<br>Step 16 ～ Step 17:<br>ReceiverDispatcher的内部类Args在MainActivity所在的线程消息循环中处理这个广播，最终是将这个广播分发给所注册的BroadcastReceiver实例的onReceive函数进行处理。</li>
</ol>

    
  </div>
</article>

</div>





  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Blog
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              Category
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              Tag
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://yoursite.com/2016/09/18/Android-浅析-Broadcast-三-发送原理/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
