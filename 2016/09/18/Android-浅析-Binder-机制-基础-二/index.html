<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.useso.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,Android_基础知识,Binder," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Binder 是 Android 系统中的一种 IPC 进程间通信结构。上一章通过文档初步认识了 Binder 是什么，本章开始照旧，从源码角度开始探索。Binder 的机制实现，这次从层次的角度来探索，通过服务端、客户端、驱动层等来详细分析。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 浅析 Binder 机制 基础 (二)">
<meta property="og:url" content="http://yoursite.com/2016/09/18/Android-浅析-Binder-机制-基础-二/index.html">
<meta property="og:site_name" content="Zhong's_blog">
<meta property="og:description" content="Binder 是 Android 系统中的一种 IPC 进程间通信结构。上一章通过文档初步认识了 Binder 是什么，本章开始照旧，从源码角度开始探索。Binder 的机制实现，这次从层次的角度来探索，通过服务端、客户端、驱动层等来详细分析。">
<meta property="og:updated_time" content="2016-09-22T08:02:10.408Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 浅析 Binder 机制 基础 (二)">
<meta name="twitter:description" content="Binder 是 Android 系统中的一种 IPC 进程间通信结构。上一章通过文档初步认识了 Binder 是什么，本章开始照旧，从源码角度开始探索。Binder 的机制实现，这次从层次的角度来探索，通过服务端、客户端、驱动层等来详细分析。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/09/18/Android-浅析-Binder-机制-基础-二/"/>

  <title> Android 浅析 Binder 机制 基础 (二) | Zhong's_blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d18587c6291210ec4a8ce3d8868a3df9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zhong's_blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Read The Funning Source Code</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android 浅析 Binder 机制 基础 (二)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-18T16:39:39+08:00" content="2016-09-18">
              2016-09-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/18/Android-浅析-Binder-机制-基础-二/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/18/Android-浅析-Binder-机制-基础-二/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Binder是一个进程间通信的机制，实质就是把对象从一个进程映射到另一个进程中。</p>
</blockquote>
<p>它主要能提供的功能：<br>1：用驱动程序来推进进程间的通信。<br>2：通过共享内存来提高性能。<br>3：位进程请求分配每个进程的线程池。<br>4：针对系统中的对象引入引用计数和跨进程的对象引用映射。<br>5：进程间同步调用。<br>最后为什么它那么重要，因为Android系统的运行都将依赖Binder驱动。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><blockquote>
<p>一个Binder服务器端就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用于接收binder驱动发送的信息，收到消息后，会执行相关的服务代码。</p>
</blockquote>
<p>做为Proxy设计模式的基础，首先定义一个抽象接口类封装Server所有功能，其中包含一系列纯虚函数留待Server和Proxy各自实现。由于这些函数需要跨进程调用，须为其一一编号，从而Server可以根据收到的编号决定调用哪个函数。其次就要引入Binder了。Server端定义另一个Binder抽象类处理来自Client的Binder请求数据包，其中最重要的成员是虚函数onTransact()。该函数分析收到的数据包，调用相应的接口函数处理请求。</p>
<p>接下来采用继承方式以接口类和Binder抽象类为基类构建Binder在Server中的实体，实现基类里所有的虚函数，包括公共接口函数以及数据包处理函数：onTransact()。这个函数的输入是来自Client的binder_transaction_data结构的数据包。前面提到，该结构里有个成员code，包含这次请求的接口函数编号。onTransact()将case-by-case地解析code值，从数据包里取出函数参数，调用接口类中相应的，已经实现的公共接口函数。函数执行完毕，如果需要返回数据就再构建一个binder_transaction_data包将返回数据包填入其中。</p>
<p>那么各个Binder实体的onTransact()又是什么时候调用呢？这就需要驱动参与了。前面说过，Binder实体须要以Binde传输结构flat_binder_object形式发送给其它进程才能建立Binder通信，而Binder实体指针就存放在该结构的handle域中。驱动根据Binder位置数组从传输数据中获取该Binder的传输结构，为它创建位于内核中的Binder节点，将Binder实体指针记录在该节点中。如果接下来有其它进程向该Binder发送数据，驱动会根据节点中记录的信息将Binder实体指针填入binder_transaction_data的target.ptr中返回给接收线程。接收线程从数据包中取出该指针，reinterpret_cast成Binder抽象类并调用onTransact()函数。由于这是个虚函数，不同的Binder实体中有各自的实现，从而可以调用到不同Binder实体提供的onTransact()。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><blockquote>
<p>客户端要想访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binder对象的服务了。</p>
</blockquote>
<p>做为Proxy设计模式的一部分，Client端的Binder同样要继承Server提供的公共接口类并实现公共函数。但这不是真正的实现，而是对远程函数调用的包装：将函数参数打包，通过Binder向Server发送申请并等待返回值。为此Client端的Binder还要知道Binder实体的相关信息，即对Binder实体的引用。该引用或是由SMgr转发过来的，对实名Binder的引用或是由另一个进程直接发送过来的，对匿名Binder的引用。</p>
<p>由于继承了同样的公共接口类，Client Binder提供了与Server Binder一样的函数原型，使用户感觉不出Server是运行在本地还是远端。Client Binder中，公共接口函数的包装方式是：创建一个binder_transaction_data数据包，将其对应的编码填入code域，将调用该函数所需的参数填入data.buffer指向的缓存中，并指明数据包的目的地，那就是已经获得的对Binder实体的引用，填入数据包的target.handle中。注意这里和Server的区别：实际上target域是个联合体，包括ptr和handle两个成员，前者用于接收数据包的Server，指向 Binder实体对应的内存空间；后者用于作为请求方的Client，存放Binder实体的引用，告知驱动数据包将路由给哪个实体。数据包准备好后，通过驱动接口发送出去。经过BC_TRANSACTION/BC_REPLY回合完成函数的远程调用并得到返回值。</p>
<h2 id="驱动层"><a href="#驱动层" class="headerlink" title="驱动层"></a>驱动层</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Binder采用AIDL来描述进程间的接口。<br>主要方法：<br>1、binder_ioctl:驱动与用户空间进程交换数据。<br>2、binder_thread_write:发送请求或返回结果。<br>3、binder_thread_read:读取结果。<br>4、binder_transaction:转发请求并返回结果。<br>5、binder_parse:数据的解析。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="主要数据结构体"><a href="#主要数据结构体" class="headerlink" title="主要数据结构体"></a>主要数据结构体</h4><p>1、binder_work<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_work &#123;</div><div class="line">    <span class="keyword">struct</span> list_head entry;</div><div class="line">    <span class="keyword">enum</span> &#123;</div><div class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,</div><div class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</div><div class="line">        BINDER_WORK_NODE,</div><div class="line">        BINDER_WORK_DEAD_BINDER,</div><div class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</div><div class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</div><div class="line">    &#125; type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>2、Binder类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    <span class="comment">//本地对象</span></div><div class="line">    BINDER_TYPE_BINDER  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    <span class="comment">//远程对象“引用”</span></div><div class="line">    BINDER_TYPE_HANDLE  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    <span class="comment">//文件</span></div><div class="line">    BINDER_TYPE_FD      = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>3、传输方式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> transaction_flags &#123;</div><div class="line">    TF_ONE_WAY  = <span class="number">0x01</span>, <span class="comment">/* this is a one-way call: async, no return */</span></div><div class="line">    TF_ROOT_OBJECT  = <span class="number">0x04</span>, <span class="comment">/* contents are the component's root object */</span></div><div class="line">    TF_STATUS_CODE  = <span class="number">0x08</span>, <span class="comment">/* contents are a 32-bit status code */</span></div><div class="line">    TF_ACCEPT_FDS   = <span class="number">0x10</span>, <span class="comment">/* allow replies with file descriptors */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>4、Binder对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * This is the flattened representation of a Binder object for transfer</div><div class="line"> * between processes.  The 'offsets' supplied as part of a binder transaction</div><div class="line"> * contains offsets into the data where these structures occur.  The Binder</div><div class="line"> * driver takes care of re-writing the structure type and data as it moves</div><div class="line"> * between processes.</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> flat_binder_object &#123;</div><div class="line">    <span class="comment">/* 8 bytes for large_flat_header. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       type; <span class="comment">//Binder类型</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags; <span class="comment">//传输方式</span></div><div class="line"></div><div class="line">    <span class="comment">/* 8 bytes of data. */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span>        *binder;    <span class="comment">/* local object */</span></div><div class="line">        <span class="keyword">signed</span> <span class="keyword">long</span> handle;     <span class="comment">/* remote object */</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/* extra data associated with local object */</span></div><div class="line">    <span class="keyword">void</span>            *cookie;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>5、Binder实际内容的结构体<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_transaction_data &#123;</div><div class="line">    <span class="comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span></div><div class="line">     * identifying the target and contents of the transaction.</div><div class="line">     */</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">size_t</span>  handle; <span class="comment">/* target descriptor of command transaction */</span></div><div class="line">        <span class="keyword">void</span>    *ptr;   <span class="comment">/* target descriptor of return transaction */</span></div><div class="line">    &#125; target;</div><div class="line">    <span class="keyword">void</span>        *cookie;    <span class="comment">/* target object cookie */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;       <span class="comment">/* transaction command */</span></div><div class="line"></div><div class="line">    <span class="comment">/* General information about the transaction. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    <span class="keyword">pid_t</span>       sender_pid;</div><div class="line">    <span class="keyword">uid_t</span>       sender_euid;</div><div class="line">    <span class="keyword">size_t</span>      data_size;  <span class="comment">/* number of bytes of data */</span></div><div class="line">    <span class="keyword">size_t</span>      offsets_size;   <span class="comment">/* number of bytes of offsets */</span></div><div class="line"></div><div class="line">    <span class="comment">/* If this transaction is inline, the data immediately</span></div><div class="line">     * follows here; otherwise, it ends with a pointer to</div><div class="line">     * the data buffer.</div><div class="line">     */</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">/* transaction data */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *buffer;</div><div class="line">            <span class="comment">/* offsets from buffer to flat_binder_object structs */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *offsets;</div><div class="line">        &#125; ptr;</div><div class="line">        <span class="keyword">uint8_t</span> buf[<span class="number">8</span>];</div><div class="line">    &#125; data;<span class="comment">//真正的数据</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>6、binder_write_read<br>作用：当Binder驱动找到处理此事件的进程后，就会把需要处理的时间的任务放在读缓冲(binder_write_read)里，返回给这个服务线程，该服务线程则会执行指定命令的操作。处理请求的线程把数据交给合适的对象来执行预定操作，然后把返回结果同样用binder_transaction_data结构封装，以写命令的方式传回Binder，并将此数据放在一个读缓冲(binder_write_read)里，返回给正在等待结果的原线程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_write_read &#123;</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; <span class="comment">/* bytes to write */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_consumed; <span class="comment">/* bytes consumed by driver */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   write_buffer;</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;  <span class="comment">/* bytes to read */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;  <span class="comment">/* bytes consumed by driver */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   read_buffer;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>7、binder_proc<br>用于保存调用Binder的各个进程或线程的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_proc &#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node proc_node;</div><div class="line">    <span class="keyword">struct</span> rb_root threads;</div><div class="line">    <span class="keyword">struct</span> rb_root nodes;</div><div class="line">    <span class="keyword">struct</span> rb_root refs_by_desc;</div><div class="line">    <span class="keyword">struct</span> rb_root refs_by_node;</div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line">    <span class="keyword">struct</span> vm_area_struct *vma;</div><div class="line">    <span class="keyword">struct</span> task_struct *tsk;</div><div class="line">    <span class="keyword">struct</span> files_struct *files;</div><div class="line">    <span class="keyword">struct</span> hlist_node deferred_work_node;</div><div class="line">    <span class="keyword">int</span> deferred_work;</div><div class="line">    <span class="keyword">void</span> *buffer;</div><div class="line">    <span class="keyword">ptrdiff_t</span> user_buffer_offset;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> list_head buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root free_buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root allocated_buffers;</div><div class="line">    <span class="keyword">size_t</span> free_async_space;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> page **pages;</div><div class="line">    <span class="keyword">size_t</span> buffer_size;</div><div class="line">    <span class="keyword">uint32_t</span> buffer_free;</div><div class="line">    <span class="keyword">struct</span> list_head todo;</div><div class="line">    <span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">    <span class="keyword">struct</span> binder_stats stats;</div><div class="line">    <span class="keyword">struct</span> list_head delivered_death;</div><div class="line">    <span class="keyword">int</span> max_threads;</div><div class="line">    <span class="keyword">int</span> requested_threads;</div><div class="line">    <span class="keyword">int</span> requested_threads_started;</div><div class="line">    <span class="keyword">int</span> ready_threads;</div><div class="line">    <span class="keyword">long</span> default_priority;</div><div class="line">    <span class="keyword">struct</span> dentry *debugfs_entry;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>8、binder_node<br>Binder节点。(略)<br>9、binder_thread<br>存储每一个单独的线程的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_thread &#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc;<span class="comment">//当前线程属于哪一个Binder进程</span></div><div class="line">    <span class="keyword">struct</span> rb_node rb_node;</div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line">    <span class="keyword">int</span> looper;<span class="comment">//线程状态信息</span></div><div class="line">    <span class="keyword">struct</span> binder_transaction *transaction_stack;<span class="comment">//接收和发送的进程和线程信息</span></div><div class="line">    <span class="keyword">struct</span> list_head todo;</div><div class="line">    <span class="keyword">uint32_t</span> return_error; <span class="comment">/* Write failed, return error code in read buf */</span></div><div class="line">    <span class="keyword">uint32_t</span> return_error2; <span class="comment">/* Write failed, return error code in read */</span></div><div class="line">        <span class="comment">/* buffer. Used when sending a reply to a dead process that */</span></div><div class="line">        <span class="comment">/* we are also waiting on */</span></div><div class="line">    <span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">    <span class="keyword">struct</span> binder_stats stats;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> binder_stats &#123;</div><div class="line">    <span class="keyword">int</span> br[_IOC_NR(BR_FAILED_REPLY) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> bc[_IOC_NR(BC_DEAD_BINDER_DONE) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> obj_created[BINDER_STAT_COUNT];</div><div class="line">    <span class="keyword">int</span> obj_deleted[BINDER_STAT_COUNT];</div><div class="line">&#125;;</div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    BINDER_LOOPER_STATE_REGISTERED  = <span class="number">0x01</span>,</div><div class="line">    BINDER_LOOPER_STATE_ENTERED     = <span class="number">0x02</span>,</div><div class="line">    BINDER_LOOPER_STATE_EXITED      = <span class="number">0x04</span>,</div><div class="line">    BINDER_LOOPER_STATE_INVALID     = <span class="number">0x08</span>,</div><div class="line">    BINDER_LOOPER_STATE_WAITING     = <span class="number">0x10</span>,</div><div class="line">    BINDER_LOOPER_STATE_NEED_RETURN = <span class="number">0x20</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>10、binder_transaction<br>中转请求和返回结果，保存接收和要发送的进程信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_transaction &#123;</div><div class="line">    <span class="keyword">int</span> debug_id;</div><div class="line">    <span class="keyword">struct</span> binder_work work;</div><div class="line">    <span class="keyword">struct</span> binder_thread *from;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *from_parent;</div><div class="line">    <span class="keyword">struct</span> binder_proc *to_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *to_thread;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *to_parent;</div><div class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</div><div class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    <span class="keyword">long</span>    priority;</div><div class="line">    <span class="keyword">long</span>    saved_priority;</div><div class="line">    <span class="keyword">uid_t</span>   sender_euid;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>11、binder_buffer<br>表示binder的缓冲区信息。(略)</p>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p>1、binder_init<br>Binder驱动初始化函数，一般需要设备驱动接口调用。Android Binder设备驱动接口函数是device_initcall，目的是不让Binder驱动支持动态编译，而且需要内核做镜像。<br>misc_register注册自己为一个Misc设备，节点位于/dev/binder。创建只读proc文件：1./proc/binder/state;2./proc/binder/stats;3./proc/binder/transactions;4./proc/binder/transaction_log;5./proc/binder/failed_transaction_log;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//操作设备文件(/dev/binder)的接口</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations binder_fops = &#123;</div><div class="line">    .owner = THIS_MODULE,</div><div class="line">    .poll = binder_poll,</div><div class="line">    .unlocked_ioctl = binder_ioctl,</div><div class="line">    .mmap = binder_mmap,</div><div class="line">    .open = binder_open,</div><div class="line">    .flush = binder_flush,</div><div class="line">    .release = binder_release,</div><div class="line">&#125;;</div><div class="line"><span class="comment">//Misc设备信息</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice binder_miscdev = &#123;</div><div class="line">    .minor = MISC_DYNAMIC_MINOR,</div><div class="line">    .name = <span class="string">"binder"</span>,</div><div class="line">    .fops = &amp;binder_fops</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">"binder"</span>);</div><div class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">    binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">"binder"</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root)</div><div class="line">        binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">"proc"</span>, binder_debugfs_dir_entry_root);</div><div class="line">    ret = misc_register(&amp;binder_miscdev);</div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</div><div class="line">        debugfs_create_file(<span class="string">"state"</span>, S_IRUGO, binder_debugfs_dir_entry_root, <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_state_fops);</div><div class="line">        debugfs_create_file(<span class="string">"stats"</span>, S_IRUGO, binder_debugfs_dir_entry_root, <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_stats_fops);</div><div class="line">        debugfs_create_file(<span class="string">"transactions"</span>, S_IRUGO, binder_debugfs_dir_entry_root, <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_transactions_fops);</div><div class="line">        debugfs_create_file(<span class="string">"transaction_log"</span>, S_IRUGO, binder_debugfs_dir_entry_root,</div><div class="line">                    &amp;binder_transaction_log,</div><div class="line">                    &amp;binder_transaction_log_fops);</div><div class="line">        debugfs_create_file(<span class="string">"failed_transaction_log"</span>, S_IRUGO, binder_debugfs_dir_entry_root,</div><div class="line">                    &amp;binder_transaction_log_failed,</div><div class="line">                    &amp;binder_transaction_log_fops);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、binder_open<br>打开Binder设备文件/dev/binder。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc;</div><div class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    get_task_struct(current);</div><div class="line">    proc-&gt;tsk = current;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</div><div class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</div><div class="line">    proc-&gt;default_priority = task_nice(current);</div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    binder_stats_created(BINDER_STAT_PROC);</div><div class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</div><div class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</div><div class="line">    filp-&gt;private_data = proc;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</div><div class="line">        <span class="keyword">char</span> strbuf[<span class="number">11</span>];</div><div class="line">        <span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, proc-&gt;pid);</div><div class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,</div><div class="line">            binder_debugfs_dir_entry_proc, proc, &amp;binder_proc_fops);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、binder_release<br>释放在打开以及其他操作过程中分配的空间并清理相关数据信息。binder_defer_work执行的操作比较复杂，采用了延迟执行的方法来提高系统的响应速度和性能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_release</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    debugfs_remove(proc-&gt;debugfs_entry);</div><div class="line">    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4、binder_flush<br>在关闭一个设备文件描述符复制时被调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_flush</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">fl_owner_t</span> id)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    binder_defer_work(proc, BINDER_DEFERRED_FLUSH);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、binder_poll<br>非阻塞型IO内核驱动函数。仅支持设备是否可以飞阻塞地读(POLLIN)，有两种等待任务：proc_work和thread_work。最后都是调用poll_wait函数实现poll操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">binder_poll</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span></div><div class="line">                <span class="keyword">struct</span> poll_table_struct *wait)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> wait_for_proc_work;</div><div class="line"></div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line"></div><div class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</div><div class="line">        list_empty(&amp;thread-&gt;todo) &amp;&amp; thread-&gt;return_error == BR_OK;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</div><div class="line">        <span class="keyword">if</span> (binder_has_proc_work(proc, thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">        poll_wait(filp, &amp;proc-&gt;wait, wait);</div><div class="line">        <span class="keyword">if</span> (binder_has_proc_work(proc, thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (binder_has_thread_work(thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">        poll_wait(filp, &amp;thread-&gt;wait, wait);</div><div class="line">        <span class="keyword">if</span> (binder_has_thread_work(thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6、binder_get_thread<br>在threads队列中查找当前的进程信息。(略)<br>7、binder_mmap<br>mmap（memory map）用于把设备内存映射到用户进程地址空间中，就可以像操作用户内存那样操作设备内存。<br>由于设备内存是在mmap操作中分配的，每个进程或线程只能执行一次映射操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">struct</span> vm_struct *area;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    <span class="comment">//检测映射内存的大小</span></div><div class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</div><div class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</div><div class="line">    <span class="comment">//检测flags</span></div><div class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</div><div class="line">        ret = -EPERM;</div><div class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</div><div class="line">        <span class="keyword">goto</span> err_bad_arg;</div><div class="line">    &#125;</div><div class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</div><div class="line">    <span class="comment">//判断是否已经映射过</span></div><div class="line">    <span class="keyword">if</span> (proc-&gt;buffer) &#123;</div><div class="line">        ret = -EBUSY;</div><div class="line">        failure_string = <span class="string">"already mapped"</span>;</div><div class="line">        <span class="keyword">goto</span> err_already_mapped;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//申请虚拟空间</span></div><div class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</div><div class="line">    <span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"get_vm_area"</span>;</div><div class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</div><div class="line">    &#125;</div><div class="line">    proc-&gt;buffer = area-&gt;addr;</div><div class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPU_CACHE_VIPT</span></div><div class="line">    <span class="keyword">if</span> (cache_is_vipt_aliasing()) &#123;</div><div class="line">        <span class="keyword">while</span> (CACHE_COLOUR((vma-&gt;vm_start ^ (<span class="keyword">uint32_t</span>)proc-&gt;buffer))) &#123;</div><div class="line">            vma-&gt;vm_start += PAGE_SIZE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc page array"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</div><div class="line">    &#125;</div><div class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</div><div class="line"></div><div class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</div><div class="line">    vma-&gt;vm_private_data = proc;</div><div class="line">    <span class="comment">//分配pages空间</span></div><div class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc small buf"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</div><div class="line">    &#125;</div><div class="line">    buffer = proc-&gt;buffer;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;buffers);</div><div class="line">    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    binder_insert_free_buffer(proc, buffer);</div><div class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</div><div class="line">    barrier();</div><div class="line">    proc-&gt;files = get_files_struct(current);</div><div class="line">    proc-&gt;vma = vma;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">err_alloc_small_buf_failed:</div><div class="line">    kfree(proc-&gt;pages);</div><div class="line">    proc-&gt;pages = <span class="literal">NULL</span>;</div><div class="line">err_alloc_pages_failed:</div><div class="line">    vfree(proc-&gt;buffer);</div><div class="line">    proc-&gt;buffer = <span class="literal">NULL</span>;</div><div class="line">err_get_vm_area_failed:</div><div class="line">err_already_mapped:</div><div class="line">err_bad_arg:</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤总结：<br>1：检查内存映射条件。<br>2：获取地址空间，并把次空间的地址记录在进程信息（buffer）中。<br>3：分配物理页面并记录下来。<br>4：将buffer插入到进程信息的buffer列表中。<br>5：调用binder_update_page_range函数将分配的物理页面和vm空间对应起来。<br>6：通过binder_insert_free_buffer函数把此进程的buffer插入到进程信息中。<br><strong>8、binder_ioctl</strong><br>Binder的ioctl命令：<br>1：首先检查数据是否完整。<br>2：从用户空间复制数据到binder_write_read结构体重。<br>3：通过write_size 和 bwr.read_size判断需要执行的操作。<br>最终的操作是inder_thread_write和binder_thread_read函数实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ           _IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_TIMEOUT     _IOW(<span class="meta-string">'b'</span>, 3, int64_t)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS      _IOW(<span class="meta-string">'b'</span>, 5, size_t)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_PRIORITY    _IOW(<span class="meta-string">'b'</span>, 6, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR      _IOW(<span class="meta-string">'b'</span>, 7, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT      _IOW(<span class="meta-string">'b'</span>, 8, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION          _IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></div></pre></td></tr></table></figure></p>
<p>核心是BINDER_WRITE_READ：<br>IPC机制就是通过此接口实现。读代码吧！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> binder_write_read bwr;</div><div class="line">  <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</div><div class="line">    ret = -EINVAL;</div><div class="line">    <span class="keyword">goto</span> err;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">    ret = -EFAULT;</div><div class="line">    <span class="keyword">goto</span> err;</div><div class="line">  &#125;</div><div class="line">  binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">         <span class="string">"binder: %d:%d write %ld at %08lx, read %ld at %08lx\n"</span>,</div><div class="line">         proc-&gt;pid, thread-&gt;pid, bwr.write_size, bwr.write_buffer,</div><div class="line">         bwr.read_size, bwr.read_buffer);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</div><div class="line">    ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">      bwr.read_consumed = <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">        ret = -EFAULT;</div><div class="line">      <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</div><div class="line">    ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</div><div class="line">    <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</div><div class="line">      wake_up_interruptible(&amp;proc-&gt;wait);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">        ret = -EFAULT;</div><div class="line">      <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">         <span class="string">"binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n"</span>,</div><div class="line">         proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,</div><div class="line">         bwr.read_consumed, bwr.read_size);</div><div class="line">  <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">    ret = -EFAULT;</div><div class="line">    <span class="keyword">goto</span> err;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h2><blockquote>
<p>主要负责管理Android系统中所有的服务。对于客户端，要与服务端进行通信时，首先要通过它来查询和取得所需要交互的服务。对于服务端，创建的同时就要向ServiceManager注册自己提供的服务，以便客户端能够进行查询和获取。</p>
</blockquote>
<p>因为这个篇章重点在于Binder，所以更多ServiceManager细节在浅析ServiceManager篇章里讲解。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag">#Android</a>
          
            <a href="/tags/Android-基础知识/" rel="tag">#Android_基础知识</a>
          
            <a href="/tags/Binder/" rel="tag">#Binder</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/18/Android-浅析-Binder-机制-基础-一/" rel="next" title="Android 浅析 Binder 机制 基础 (一)">
                <i class="fa fa-chevron-left"></i> Android 浅析 Binder 机制 基础 (一)
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/18/Android-浅析-Binder-机制-基础-三/" rel="prev" title="Android 浅析 Binder 机制 基础 (三)">
                Android 浅析 Binder 机制 基础 (三) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/09/18/Android-浅析-Binder-机制-基础-二/"
           data-title="Android 浅析 Binder 机制 基础 (二)" data-url="http://yoursite.com/2016/09/18/Android-浅析-Binder-机制-基础-二/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="钟华健" />
          <p class="site-author-name" itemprop="name">钟华健</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jasonzhong" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务端"><span class="nav-number">3.</span> <span class="nav-text">服务端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端"><span class="nav-number">4.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#驱动层"><span class="nav-number">5.</span> <span class="nav-text">驱动层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">5.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">5.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要数据结构体"><span class="nav-number">5.2.1.</span> <span class="nav-text">主要数据结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主要方法"><span class="nav-number">5.2.2.</span> <span class="nav-text">主要方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServiceManager"><span class="nav-number">6.</span> <span class="nav-text">ServiceManager</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">钟华健</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jasonzhong"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
