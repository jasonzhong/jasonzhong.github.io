<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Android 浅析 Binder 机制 基础 (二) | Zhong&#39;s_blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Android,Binder,Android_基础知识," />
  

  <meta name="description" content="Binder 是 Android 系统中的一种 IPC 进程间通信结构。上一章通过文档初步认识了 Binder 是什么，本章开始照旧，从源码角度开始探索。Binder 的机制实现，这次从层次的角度来探索，通过服务端、客户端、驱动层等来详细分析。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 浅析 Binder 机制 基础 (二)">
<meta property="og:url" content="http://yoursite.com/2016/09/18/Android-浅析-Binder-机制-基础-二/index.html">
<meta property="og:site_name" content="Zhong's_blog">
<meta property="og:description" content="Binder 是 Android 系统中的一种 IPC 进程间通信结构。上一章通过文档初步认识了 Binder 是什么，本章开始照旧，从源码角度开始探索。Binder 的机制实现，这次从层次的角度来探索，通过服务端、客户端、驱动层等来详细分析。">
<meta property="og:updated_time" content="2016-09-22T08:02:10.408Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 浅析 Binder 机制 基础 (二)">
<meta name="twitter:description" content="Binder 是 Android 系统中的一种 IPC 进程间通信结构。上一章通过文档初步认识了 Binder 是什么，本章开始照旧，从源码角度开始探索。Binder 的机制实现，这次从层次的角度来探索，通过服务端、客户端、驱动层等来详细分析。">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=028c63b1" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">Tag</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">Tag</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            Blog
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            Tag
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            About
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端"><span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#驱动层"><span class="toc-text">驱动层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要数据结构体"><span class="toc-text">主要数据结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主要方法"><span class="toc-text">主要方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServiceManager"><span class="toc-text">ServiceManager</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Android-浅析-Binder-机制-基础-二" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Android 浅析 Binder 机制 基础 (二)</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.09.18</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>钟华健</span>
        </span>
      

      


      
        <span>
          <i class="icon-comment"></i>
          <a href="https://github.com/jasonzhong/2016/09/18/Android-浅析-Binder-机制-基础-二/#disqus_thread"></a>
        </span>
      

    </div>
  </header>

  <div class="article-content">
    
      <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Binder是一个进程间通信的机制，实质就是把对象从一个进程映射到另一个进程中。</p>
</blockquote>
<p>它主要能提供的功能：<br>1：用驱动程序来推进进程间的通信。<br>2：通过共享内存来提高性能。<br>3：位进程请求分配每个进程的线程池。<br>4：针对系统中的对象引入引用计数和跨进程的对象引用映射。<br>5：进程间同步调用。<br>最后为什么它那么重要，因为Android系统的运行都将依赖Binder驱动。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><blockquote>
<p>一个Binder服务器端就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用于接收binder驱动发送的信息，收到消息后，会执行相关的服务代码。</p>
</blockquote>
<p>做为Proxy设计模式的基础，首先定义一个抽象接口类封装Server所有功能，其中包含一系列纯虚函数留待Server和Proxy各自实现。由于这些函数需要跨进程调用，须为其一一编号，从而Server可以根据收到的编号决定调用哪个函数。其次就要引入Binder了。Server端定义另一个Binder抽象类处理来自Client的Binder请求数据包，其中最重要的成员是虚函数onTransact()。该函数分析收到的数据包，调用相应的接口函数处理请求。</p>
<p>接下来采用继承方式以接口类和Binder抽象类为基类构建Binder在Server中的实体，实现基类里所有的虚函数，包括公共接口函数以及数据包处理函数：onTransact()。这个函数的输入是来自Client的binder_transaction_data结构的数据包。前面提到，该结构里有个成员code，包含这次请求的接口函数编号。onTransact()将case-by-case地解析code值，从数据包里取出函数参数，调用接口类中相应的，已经实现的公共接口函数。函数执行完毕，如果需要返回数据就再构建一个binder_transaction_data包将返回数据包填入其中。</p>
<p>那么各个Binder实体的onTransact()又是什么时候调用呢？这就需要驱动参与了。前面说过，Binder实体须要以Binde传输结构flat_binder_object形式发送给其它进程才能建立Binder通信，而Binder实体指针就存放在该结构的handle域中。驱动根据Binder位置数组从传输数据中获取该Binder的传输结构，为它创建位于内核中的Binder节点，将Binder实体指针记录在该节点中。如果接下来有其它进程向该Binder发送数据，驱动会根据节点中记录的信息将Binder实体指针填入binder_transaction_data的target.ptr中返回给接收线程。接收线程从数据包中取出该指针，reinterpret_cast成Binder抽象类并调用onTransact()函数。由于这是个虚函数，不同的Binder实体中有各自的实现，从而可以调用到不同Binder实体提供的onTransact()。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><blockquote>
<p>客户端要想访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binder对象的服务了。</p>
</blockquote>
<p>做为Proxy设计模式的一部分，Client端的Binder同样要继承Server提供的公共接口类并实现公共函数。但这不是真正的实现，而是对远程函数调用的包装：将函数参数打包，通过Binder向Server发送申请并等待返回值。为此Client端的Binder还要知道Binder实体的相关信息，即对Binder实体的引用。该引用或是由SMgr转发过来的，对实名Binder的引用或是由另一个进程直接发送过来的，对匿名Binder的引用。</p>
<p>由于继承了同样的公共接口类，Client Binder提供了与Server Binder一样的函数原型，使用户感觉不出Server是运行在本地还是远端。Client Binder中，公共接口函数的包装方式是：创建一个binder_transaction_data数据包，将其对应的编码填入code域，将调用该函数所需的参数填入data.buffer指向的缓存中，并指明数据包的目的地，那就是已经获得的对Binder实体的引用，填入数据包的target.handle中。注意这里和Server的区别：实际上target域是个联合体，包括ptr和handle两个成员，前者用于接收数据包的Server，指向 Binder实体对应的内存空间；后者用于作为请求方的Client，存放Binder实体的引用，告知驱动数据包将路由给哪个实体。数据包准备好后，通过驱动接口发送出去。经过BC_TRANSACTION/BC_REPLY回合完成函数的远程调用并得到返回值。</p>
<h2 id="驱动层"><a href="#驱动层" class="headerlink" title="驱动层"></a>驱动层</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Binder采用AIDL来描述进程间的接口。<br>主要方法：<br>1、binder_ioctl:驱动与用户空间进程交换数据。<br>2、binder_thread_write:发送请求或返回结果。<br>3、binder_thread_read:读取结果。<br>4、binder_transaction:转发请求并返回结果。<br>5、binder_parse:数据的解析。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="主要数据结构体"><a href="#主要数据结构体" class="headerlink" title="主要数据结构体"></a>主要数据结构体</h4><p>1、binder_work<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_work &#123;</div><div class="line">    <span class="keyword">struct</span> list_head entry;</div><div class="line">    <span class="keyword">enum</span> &#123;</div><div class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,</div><div class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</div><div class="line">        BINDER_WORK_NODE,</div><div class="line">        BINDER_WORK_DEAD_BINDER,</div><div class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</div><div class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</div><div class="line">    &#125; type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>2、Binder类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    <span class="comment">//本地对象</span></div><div class="line">    BINDER_TYPE_BINDER  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    <span class="comment">//远程对象“引用”</span></div><div class="line">    BINDER_TYPE_HANDLE  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    <span class="comment">//文件</span></div><div class="line">    BINDER_TYPE_FD      = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>3、传输方式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> transaction_flags &#123;</div><div class="line">    TF_ONE_WAY  = <span class="number">0x01</span>, <span class="comment">/* this is a one-way call: async, no return */</span></div><div class="line">    TF_ROOT_OBJECT  = <span class="number">0x04</span>, <span class="comment">/* contents are the component's root object */</span></div><div class="line">    TF_STATUS_CODE  = <span class="number">0x08</span>, <span class="comment">/* contents are a 32-bit status code */</span></div><div class="line">    TF_ACCEPT_FDS   = <span class="number">0x10</span>, <span class="comment">/* allow replies with file descriptors */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>4、Binder对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * This is the flattened representation of a Binder object for transfer</div><div class="line"> * between processes.  The 'offsets' supplied as part of a binder transaction</div><div class="line"> * contains offsets into the data where these structures occur.  The Binder</div><div class="line"> * driver takes care of re-writing the structure type and data as it moves</div><div class="line"> * between processes.</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> flat_binder_object &#123;</div><div class="line">    <span class="comment">/* 8 bytes for large_flat_header. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       type; <span class="comment">//Binder类型</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags; <span class="comment">//传输方式</span></div><div class="line"></div><div class="line">    <span class="comment">/* 8 bytes of data. */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span>        *binder;    <span class="comment">/* local object */</span></div><div class="line">        <span class="keyword">signed</span> <span class="keyword">long</span> handle;     <span class="comment">/* remote object */</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/* extra data associated with local object */</span></div><div class="line">    <span class="keyword">void</span>            *cookie;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>5、Binder实际内容的结构体<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_transaction_data &#123;</div><div class="line">    <span class="comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span></div><div class="line">     * identifying the target and contents of the transaction.</div><div class="line">     */</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">size_t</span>  handle; <span class="comment">/* target descriptor of command transaction */</span></div><div class="line">        <span class="keyword">void</span>    *ptr;   <span class="comment">/* target descriptor of return transaction */</span></div><div class="line">    &#125; target;</div><div class="line">    <span class="keyword">void</span>        *cookie;    <span class="comment">/* target object cookie */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;       <span class="comment">/* transaction command */</span></div><div class="line"></div><div class="line">    <span class="comment">/* General information about the transaction. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    <span class="keyword">pid_t</span>       sender_pid;</div><div class="line">    <span class="keyword">uid_t</span>       sender_euid;</div><div class="line">    <span class="keyword">size_t</span>      data_size;  <span class="comment">/* number of bytes of data */</span></div><div class="line">    <span class="keyword">size_t</span>      offsets_size;   <span class="comment">/* number of bytes of offsets */</span></div><div class="line"></div><div class="line">    <span class="comment">/* If this transaction is inline, the data immediately</span></div><div class="line">     * follows here; otherwise, it ends with a pointer to</div><div class="line">     * the data buffer.</div><div class="line">     */</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">/* transaction data */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *buffer;</div><div class="line">            <span class="comment">/* offsets from buffer to flat_binder_object structs */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *offsets;</div><div class="line">        &#125; ptr;</div><div class="line">        <span class="keyword">uint8_t</span> buf[<span class="number">8</span>];</div><div class="line">    &#125; data;<span class="comment">//真正的数据</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>6、binder_write_read<br>作用：当Binder驱动找到处理此事件的进程后，就会把需要处理的时间的任务放在读缓冲(binder_write_read)里，返回给这个服务线程，该服务线程则会执行指定命令的操作。处理请求的线程把数据交给合适的对象来执行预定操作，然后把返回结果同样用binder_transaction_data结构封装，以写命令的方式传回Binder，并将此数据放在一个读缓冲(binder_write_read)里，返回给正在等待结果的原线程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_write_read &#123;</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; <span class="comment">/* bytes to write */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_consumed; <span class="comment">/* bytes consumed by driver */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   write_buffer;</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;  <span class="comment">/* bytes to read */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;  <span class="comment">/* bytes consumed by driver */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   read_buffer;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>7、binder_proc<br>用于保存调用Binder的各个进程或线程的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_proc &#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node proc_node;</div><div class="line">    <span class="keyword">struct</span> rb_root threads;</div><div class="line">    <span class="keyword">struct</span> rb_root nodes;</div><div class="line">    <span class="keyword">struct</span> rb_root refs_by_desc;</div><div class="line">    <span class="keyword">struct</span> rb_root refs_by_node;</div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line">    <span class="keyword">struct</span> vm_area_struct *vma;</div><div class="line">    <span class="keyword">struct</span> task_struct *tsk;</div><div class="line">    <span class="keyword">struct</span> files_struct *files;</div><div class="line">    <span class="keyword">struct</span> hlist_node deferred_work_node;</div><div class="line">    <span class="keyword">int</span> deferred_work;</div><div class="line">    <span class="keyword">void</span> *buffer;</div><div class="line">    <span class="keyword">ptrdiff_t</span> user_buffer_offset;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> list_head buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root free_buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root allocated_buffers;</div><div class="line">    <span class="keyword">size_t</span> free_async_space;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> page **pages;</div><div class="line">    <span class="keyword">size_t</span> buffer_size;</div><div class="line">    <span class="keyword">uint32_t</span> buffer_free;</div><div class="line">    <span class="keyword">struct</span> list_head todo;</div><div class="line">    <span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">    <span class="keyword">struct</span> binder_stats stats;</div><div class="line">    <span class="keyword">struct</span> list_head delivered_death;</div><div class="line">    <span class="keyword">int</span> max_threads;</div><div class="line">    <span class="keyword">int</span> requested_threads;</div><div class="line">    <span class="keyword">int</span> requested_threads_started;</div><div class="line">    <span class="keyword">int</span> ready_threads;</div><div class="line">    <span class="keyword">long</span> default_priority;</div><div class="line">    <span class="keyword">struct</span> dentry *debugfs_entry;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>8、binder_node<br>Binder节点。(略)<br>9、binder_thread<br>存储每一个单独的线程的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_thread &#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc;<span class="comment">//当前线程属于哪一个Binder进程</span></div><div class="line">    <span class="keyword">struct</span> rb_node rb_node;</div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line">    <span class="keyword">int</span> looper;<span class="comment">//线程状态信息</span></div><div class="line">    <span class="keyword">struct</span> binder_transaction *transaction_stack;<span class="comment">//接收和发送的进程和线程信息</span></div><div class="line">    <span class="keyword">struct</span> list_head todo;</div><div class="line">    <span class="keyword">uint32_t</span> return_error; <span class="comment">/* Write failed, return error code in read buf */</span></div><div class="line">    <span class="keyword">uint32_t</span> return_error2; <span class="comment">/* Write failed, return error code in read */</span></div><div class="line">        <span class="comment">/* buffer. Used when sending a reply to a dead process that */</span></div><div class="line">        <span class="comment">/* we are also waiting on */</span></div><div class="line">    <span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">    <span class="keyword">struct</span> binder_stats stats;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> binder_stats &#123;</div><div class="line">    <span class="keyword">int</span> br[_IOC_NR(BR_FAILED_REPLY) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> bc[_IOC_NR(BC_DEAD_BINDER_DONE) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> obj_created[BINDER_STAT_COUNT];</div><div class="line">    <span class="keyword">int</span> obj_deleted[BINDER_STAT_COUNT];</div><div class="line">&#125;;</div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    BINDER_LOOPER_STATE_REGISTERED  = <span class="number">0x01</span>,</div><div class="line">    BINDER_LOOPER_STATE_ENTERED     = <span class="number">0x02</span>,</div><div class="line">    BINDER_LOOPER_STATE_EXITED      = <span class="number">0x04</span>,</div><div class="line">    BINDER_LOOPER_STATE_INVALID     = <span class="number">0x08</span>,</div><div class="line">    BINDER_LOOPER_STATE_WAITING     = <span class="number">0x10</span>,</div><div class="line">    BINDER_LOOPER_STATE_NEED_RETURN = <span class="number">0x20</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>10、binder_transaction<br>中转请求和返回结果，保存接收和要发送的进程信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_transaction &#123;</div><div class="line">    <span class="keyword">int</span> debug_id;</div><div class="line">    <span class="keyword">struct</span> binder_work work;</div><div class="line">    <span class="keyword">struct</span> binder_thread *from;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *from_parent;</div><div class="line">    <span class="keyword">struct</span> binder_proc *to_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *to_thread;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *to_parent;</div><div class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</div><div class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    <span class="keyword">long</span>    priority;</div><div class="line">    <span class="keyword">long</span>    saved_priority;</div><div class="line">    <span class="keyword">uid_t</span>   sender_euid;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>11、binder_buffer<br>表示binder的缓冲区信息。(略)</p>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p>1、binder_init<br>Binder驱动初始化函数，一般需要设备驱动接口调用。Android Binder设备驱动接口函数是device_initcall，目的是不让Binder驱动支持动态编译，而且需要内核做镜像。<br>misc_register注册自己为一个Misc设备，节点位于/dev/binder。创建只读proc文件：1./proc/binder/state;2./proc/binder/stats;3./proc/binder/transactions;4./proc/binder/transaction_log;5./proc/binder/failed_transaction_log;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//操作设备文件(/dev/binder)的接口</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations binder_fops = &#123;</div><div class="line">    .owner = THIS_MODULE,</div><div class="line">    .poll = binder_poll,</div><div class="line">    .unlocked_ioctl = binder_ioctl,</div><div class="line">    .mmap = binder_mmap,</div><div class="line">    .open = binder_open,</div><div class="line">    .flush = binder_flush,</div><div class="line">    .release = binder_release,</div><div class="line">&#125;;</div><div class="line"><span class="comment">//Misc设备信息</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice binder_miscdev = &#123;</div><div class="line">    .minor = MISC_DYNAMIC_MINOR,</div><div class="line">    .name = <span class="string">"binder"</span>,</div><div class="line">    .fops = &amp;binder_fops</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">"binder"</span>);</div><div class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">    binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">"binder"</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root)</div><div class="line">        binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">"proc"</span>, binder_debugfs_dir_entry_root);</div><div class="line">    ret = misc_register(&amp;binder_miscdev);</div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</div><div class="line">        debugfs_create_file(<span class="string">"state"</span>, S_IRUGO, binder_debugfs_dir_entry_root, <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_state_fops);</div><div class="line">        debugfs_create_file(<span class="string">"stats"</span>, S_IRUGO, binder_debugfs_dir_entry_root, <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_stats_fops);</div><div class="line">        debugfs_create_file(<span class="string">"transactions"</span>, S_IRUGO, binder_debugfs_dir_entry_root, <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_transactions_fops);</div><div class="line">        debugfs_create_file(<span class="string">"transaction_log"</span>, S_IRUGO, binder_debugfs_dir_entry_root,</div><div class="line">                    &amp;binder_transaction_log,</div><div class="line">                    &amp;binder_transaction_log_fops);</div><div class="line">        debugfs_create_file(<span class="string">"failed_transaction_log"</span>, S_IRUGO, binder_debugfs_dir_entry_root,</div><div class="line">                    &amp;binder_transaction_log_failed,</div><div class="line">                    &amp;binder_transaction_log_fops);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、binder_open<br>打开Binder设备文件/dev/binder。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc;</div><div class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    get_task_struct(current);</div><div class="line">    proc-&gt;tsk = current;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</div><div class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</div><div class="line">    proc-&gt;default_priority = task_nice(current);</div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    binder_stats_created(BINDER_STAT_PROC);</div><div class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</div><div class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</div><div class="line">    filp-&gt;private_data = proc;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</div><div class="line">        <span class="keyword">char</span> strbuf[<span class="number">11</span>];</div><div class="line">        <span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, proc-&gt;pid);</div><div class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,</div><div class="line">            binder_debugfs_dir_entry_proc, proc, &amp;binder_proc_fops);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、binder_release<br>释放在打开以及其他操作过程中分配的空间并清理相关数据信息。binder_defer_work执行的操作比较复杂，采用了延迟执行的方法来提高系统的响应速度和性能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_release</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    debugfs_remove(proc-&gt;debugfs_entry);</div><div class="line">    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4、binder_flush<br>在关闭一个设备文件描述符复制时被调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_flush</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">fl_owner_t</span> id)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    binder_defer_work(proc, BINDER_DEFERRED_FLUSH);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、binder_poll<br>非阻塞型IO内核驱动函数。仅支持设备是否可以飞阻塞地读(POLLIN)，有两种等待任务：proc_work和thread_work。最后都是调用poll_wait函数实现poll操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">binder_poll</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span></div><div class="line">                <span class="keyword">struct</span> poll_table_struct *wait)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> wait_for_proc_work;</div><div class="line"></div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line"></div><div class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</div><div class="line">        list_empty(&amp;thread-&gt;todo) &amp;&amp; thread-&gt;return_error == BR_OK;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</div><div class="line">        <span class="keyword">if</span> (binder_has_proc_work(proc, thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">        poll_wait(filp, &amp;proc-&gt;wait, wait);</div><div class="line">        <span class="keyword">if</span> (binder_has_proc_work(proc, thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (binder_has_thread_work(thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">        poll_wait(filp, &amp;thread-&gt;wait, wait);</div><div class="line">        <span class="keyword">if</span> (binder_has_thread_work(thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6、binder_get_thread<br>在threads队列中查找当前的进程信息。(略)<br>7、binder_mmap<br>mmap（memory map）用于把设备内存映射到用户进程地址空间中，就可以像操作用户内存那样操作设备内存。<br>由于设备内存是在mmap操作中分配的，每个进程或线程只能执行一次映射操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">struct</span> vm_struct *area;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    <span class="comment">//检测映射内存的大小</span></div><div class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</div><div class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</div><div class="line">    <span class="comment">//检测flags</span></div><div class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</div><div class="line">        ret = -EPERM;</div><div class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</div><div class="line">        <span class="keyword">goto</span> err_bad_arg;</div><div class="line">    &#125;</div><div class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</div><div class="line">    <span class="comment">//判断是否已经映射过</span></div><div class="line">    <span class="keyword">if</span> (proc-&gt;buffer) &#123;</div><div class="line">        ret = -EBUSY;</div><div class="line">        failure_string = <span class="string">"already mapped"</span>;</div><div class="line">        <span class="keyword">goto</span> err_already_mapped;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//申请虚拟空间</span></div><div class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</div><div class="line">    <span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"get_vm_area"</span>;</div><div class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</div><div class="line">    &#125;</div><div class="line">    proc-&gt;buffer = area-&gt;addr;</div><div class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPU_CACHE_VIPT</span></div><div class="line">    <span class="keyword">if</span> (cache_is_vipt_aliasing()) &#123;</div><div class="line">        <span class="keyword">while</span> (CACHE_COLOUR((vma-&gt;vm_start ^ (<span class="keyword">uint32_t</span>)proc-&gt;buffer))) &#123;</div><div class="line">            vma-&gt;vm_start += PAGE_SIZE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc page array"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</div><div class="line">    &#125;</div><div class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</div><div class="line"></div><div class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</div><div class="line">    vma-&gt;vm_private_data = proc;</div><div class="line">    <span class="comment">//分配pages空间</span></div><div class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc small buf"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</div><div class="line">    &#125;</div><div class="line">    buffer = proc-&gt;buffer;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;buffers);</div><div class="line">    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    binder_insert_free_buffer(proc, buffer);</div><div class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</div><div class="line">    barrier();</div><div class="line">    proc-&gt;files = get_files_struct(current);</div><div class="line">    proc-&gt;vma = vma;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">err_alloc_small_buf_failed:</div><div class="line">    kfree(proc-&gt;pages);</div><div class="line">    proc-&gt;pages = <span class="literal">NULL</span>;</div><div class="line">err_alloc_pages_failed:</div><div class="line">    vfree(proc-&gt;buffer);</div><div class="line">    proc-&gt;buffer = <span class="literal">NULL</span>;</div><div class="line">err_get_vm_area_failed:</div><div class="line">err_already_mapped:</div><div class="line">err_bad_arg:</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤总结：<br>1：检查内存映射条件。<br>2：获取地址空间，并把次空间的地址记录在进程信息（buffer）中。<br>3：分配物理页面并记录下来。<br>4：将buffer插入到进程信息的buffer列表中。<br>5：调用binder_update_page_range函数将分配的物理页面和vm空间对应起来。<br>6：通过binder_insert_free_buffer函数把此进程的buffer插入到进程信息中。<br><strong>8、binder_ioctl</strong><br>Binder的ioctl命令：<br>1：首先检查数据是否完整。<br>2：从用户空间复制数据到binder_write_read结构体重。<br>3：通过write_size 和 bwr.read_size判断需要执行的操作。<br>最终的操作是inder_thread_write和binder_thread_read函数实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ           _IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_TIMEOUT     _IOW(<span class="meta-string">'b'</span>, 3, int64_t)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS      _IOW(<span class="meta-string">'b'</span>, 5, size_t)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_PRIORITY    _IOW(<span class="meta-string">'b'</span>, 6, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR      _IOW(<span class="meta-string">'b'</span>, 7, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT      _IOW(<span class="meta-string">'b'</span>, 8, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION          _IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></div></pre></td></tr></table></figure></p>
<p>核心是BINDER_WRITE_READ：<br>IPC机制就是通过此接口实现。读代码吧！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> binder_write_read bwr;</div><div class="line">  <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</div><div class="line">    ret = -EINVAL;</div><div class="line">    <span class="keyword">goto</span> err;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">    ret = -EFAULT;</div><div class="line">    <span class="keyword">goto</span> err;</div><div class="line">  &#125;</div><div class="line">  binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">         <span class="string">"binder: %d:%d write %ld at %08lx, read %ld at %08lx\n"</span>,</div><div class="line">         proc-&gt;pid, thread-&gt;pid, bwr.write_size, bwr.write_buffer,</div><div class="line">         bwr.read_size, bwr.read_buffer);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</div><div class="line">    ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">      bwr.read_consumed = <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">        ret = -EFAULT;</div><div class="line">      <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</div><div class="line">    ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</div><div class="line">    <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</div><div class="line">      wake_up_interruptible(&amp;proc-&gt;wait);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">        ret = -EFAULT;</div><div class="line">      <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">         <span class="string">"binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n"</span>,</div><div class="line">         proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,</div><div class="line">         bwr.read_consumed, bwr.read_size);</div><div class="line">  <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">    ret = -EFAULT;</div><div class="line">    <span class="keyword">goto</span> err;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h2><blockquote>
<p>主要负责管理Android系统中所有的服务。对于客户端，要与服务端进行通信时，首先要通过它来查询和取得所需要交互的服务。对于服务端，创建的同时就要向ServiceManager注册自己提供的服务，以便客户端能够进行查询和获取。</p>
</blockquote>
<p>因为这个篇章重点在于Binder，所以更多ServiceManager细节在浅析ServiceManager篇章里讲解。</p>

    
  </div>
</article>

</div>





  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Blog
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              Tag
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://yoursite.com/2016/09/18/Android-浅析-Binder-机制-基础-二/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
