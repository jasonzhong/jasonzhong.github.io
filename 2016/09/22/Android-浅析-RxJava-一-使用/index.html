<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Android 浅析 RxJava (一) 使用 | Zhong&#39;s_blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Android,开源库,RxJava," />
  

  <meta name="description" content="RxJava 是一个被设计实现为灵活扩展功能的 java 虚拟机：一个由异步和事件组成的观测序列为基础的程序库。它扩展了观察者模式来支持数据/事件序列和增加了 operators 允许你为组成序列的共同声明而抽象出来的东西之类的低级线程同步问题，线程安全和并发数据结构。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 浅析 RxJava (一) 使用">
<meta property="og:url" content="http://yoursite.com/2016/09/22/Android-浅析-RxJava-一-使用/index.html">
<meta property="og:site_name" content="Zhong's_blog">
<meta property="og:description" content="RxJava 是一个被设计实现为灵活扩展功能的 java 虚拟机：一个由异步和事件组成的观测序列为基础的程序库。它扩展了观察者模式来支持数据/事件序列和增加了 operators 允许你为组成序列的共同声明而抽象出来的东西之类的低级线程同步问题，线程安全和并发数据结构。">
<meta property="og:updated_time" content="2016-09-22T04:06:02.373Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 浅析 RxJava (一) 使用">
<meta name="twitter:description" content="RxJava 是一个被设计实现为灵活扩展功能的 java 虚拟机：一个由异步和事件组成的观测序列为基础的程序库。它扩展了观察者模式来支持数据/事件序列和增加了 operators 允许你为组成序列的共同声明而抽象出来的东西之类的低级线程同步问题，线程安全和并发数据结构。">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=028c63b1" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">Tag</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">Tag</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            Blog
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            Tag
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            About
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概括"><span class="toc-text">概括</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简单使用"><span class="toc-text">简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-1：创建Observer"><span class="toc-text">Step 1：创建Observer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-2：创建Observable"><span class="toc-text">Step 2：创建Observable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-3：Subscribe"><span class="toc-text">Step 3：Subscribe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不完整定义回调"><span class="toc-text">不完整定义回调</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用例子"><span class="toc-text">使用例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scheduler-线程控制"><span class="toc-text">Scheduler 线程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进阶使用"><span class="toc-text">进阶使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Operators-操作符"><span class="toc-text">Operators 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-操作符"><span class="toc-text">map 操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flatMap-操作符"><span class="toc-text">flatMap 操作符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最后在说下RxJava-的实际使用意义"><span class="toc-text">最后在说下RxJava 的实际使用意义</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Android-浅析-RxJava-一-使用" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Android 浅析 RxJava (一) 使用</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.09.22</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>钟华健</span>
        </span>
      

      


      
        <span>
          <i class="icon-comment"></i>
          <a href="https://github.com/jasonzhong/2016/09/22/Android-浅析-RxJava-一-使用/#disqus_thread"></a>
        </span>
      

    </div>
  </header>

  <div class="article-content">
    
      <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.<br>RxJava 是一个被设计实现为灵活扩展功能的 java 虚拟机：一个由异步和事件组成的观测序列为基础的程序库。</p>
<p>It extends the observer pattern to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.<br>它扩展了观察者模式来支持data/events序列和增加了operators来允许你把序列以声明方式组成在一起并一边将关注的事情抽象化，比如低线程，同步，线程安全和并发数据结构。</p>
</blockquote>
<p>RxJava 是一个响应式编程框架，采用观察者设计模式。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="Step-1：创建Observer"><a href="#Step-1：创建Observer" class="headerlink" title="Step 1：创建Observer"></a>Step 1：创建Observer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observer&lt;T&gt; observer = <span class="keyword">new</span> Observer&lt;T&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T s)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>除了Observer，还有一个内置的Subscriber类实现了Observer的抽象类。Subscriber类对Observer类进行了扩展。<br>它们的实现基本上是一样的，对于区别，主要有这两点：</p>
<ol>
<li>onStart(): 这是 Subscriber 增加的方法。在 subscribe 刚开始，而事件还未发送之前被调用。</li>
<li>unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。</li>
</ol>
<h3 id="Step-2：创建Observable"><a href="#Step-2：创建Observable" class="headerlink" title="Step 2：创建Observable"></a>Step 2：创建Observable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;T&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(T);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>RxJava 还提供了其它快速创建事件队列的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>);</div><div class="line"></div><div class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>&#125;;</div><div class="line">Observable observable = Observable.from(words);</div></pre></td></tr></table></figure></p>
<h3 id="Step-3：Subscribe"><a href="#Step-3：Subscribe" class="headerlink" title="Step 3：Subscribe"></a>Step 3：Subscribe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div><div class="line"><span class="comment">// 或者：</span></div><div class="line">observable.subscribe(subscriber);</div></pre></td></tr></table></figure>
<p>Observable.subscribe(Subscriber) 的内部实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subscriber.onStart();</div><div class="line">onSubscribe.call(subscriber);</div></pre></td></tr></table></figure></p>
<p>在接收到订阅后马上会开始发送事件。</p>
<h4 id="不完整定义回调"><a href="#不完整定义回调" class="headerlink" title="不完整定义回调"></a>不完整定义回调</h4><p>subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">    <span class="comment">// onNext()</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.d(tag, s);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line">    <span class="comment">// onError()</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">        <span class="comment">// Error handling</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">Action0 onCompletedAction = <span class="keyword">new</span> Action0() &#123;</div><div class="line">    <span class="comment">// onCompleted()</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.d(tag, <span class="string">"completed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></div><div class="line">observable.subscribe(onNextAction);</div><div class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span></div><div class="line">observable.subscribe(onNextAction, onErrorAction);</div><div class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span></div><div class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</div></pre></td></tr></table></figure></p>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将字符串数组 names 中的所有字符串依次打印出来：</span></div><div class="line">String[] names = ...;</div><div class="line">Observable.from(names)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            Log.d(tag, name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="Scheduler-线程控制"><a href="#Scheduler-线程控制" class="headerlink" title="Scheduler 线程控制"></a>Scheduler 线程控制</h2><blockquote>
<p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">    .subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></div><div class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span> </span>&#123;</div><div class="line">            Log.d(tag, <span class="string">"number:"</span> + number);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<ol>
<li>subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。</li>
<li>observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。</li>
</ol>
<p>这段代码就是说，由 subscribeOn(Schedulers.io()) 的指定，创建的事件内容<code>(1,2,3,4)</code>将由io线程发出，而由 observeOn(AndroidScheculers.mainThread()) 的指定，subscriber 数字的 Log 将发生在主线程。</p>
<h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="Operators-操作符"><a href="#Operators-操作符" class="headerlink" title="Operators 操作符"></a>Operators 操作符</h3><blockquote>
<p>Operators在消息发送者Observable和消息消费者Subscriber之间起到操纵消息的作用。</p>
</blockquote>
<h4 id="map-操作符"><a href="#map-操作符" class="headerlink" title="map 操作符"></a>map 操作符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello, world!"</span>)</div><div class="line">    .map(<span class="keyword">new</span> Func1&lt;String, String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> s + <span class="string">" -Dan"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(s -&gt; System.out.println(s));</div></pre></td></tr></table></figure>
<p>当我们在消息的过程中对消息进行转换，最简单的方法就是使用 map 操作符。<br>map()函数的特点是：它不一定发送和原始的Observable一样的数据类型。</p>
<h4 id="flatMap-操作符"><a href="#flatMap-操作符" class="headerlink" title="flatMap 操作符"></a>flatMap 操作符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable&lt;ArrayList&lt;String&gt;&gt; query(String text);</div><div class="line">query(<span class="string">"a lot text"</span>)</div><div class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;ArrayList&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(ArrayList&lt;String&gt; s)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Observable.from(s);</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">            System.out.println(s);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>利用 flatMap 操作符可以很方便的将一个 list 的字符串分开发出来，在 faltMap 函数内的 Func1跟之前的 Action1 意思一样，并且返回值是一个新的 Observable 对象。</p>
<p>至于更多的操作符会在未来添加。</p>
<h2 id="最后在说下RxJava-的实际使用意义"><a href="#最后在说下RxJava-的实际使用意义" class="headerlink" title="最后在说下RxJava 的实际使用意义"></a>最后在说下RxJava 的实际使用意义</h2><ul>
<li>Observable 和 Subscriber 他们本身就是一个处理事件的通用框架。</li>
<li>Observable 和 Subscriber 在它们之间的一系列转换步骤是相互独立的。</li>
</ul>

    
  </div>
</article>

</div>





  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Blog
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              Tag
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://yoursite.com/2016/09/22/Android-浅析-RxJava-一-使用/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
