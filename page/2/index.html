<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android-浅析-Binder-机制-基础-三" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/18/Android-浅析-Binder-机制-基础-三/" class="article-date">
  <time datetime="2016-09-18T09:55:18.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/Android-浅析-Binder-机制-基础-三/">Android 浅析 Binder 机制 基础 (三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="Binder-架构"><a href="#Binder-架构" class="headerlink" title="Binder 架构"></a>Binder 架构</h2><blockquote>
<p>Android 的Binder机制就是一个C/S架构，整个机制包括：<br>1、ServiceManager；<br>2、服务端Server；<br>3、客户端client；<br>4、服务代理proxy；<br>5、Binder驱动；</p>
</blockquote>
<p>Android Binder 系统架构图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">st=&gt;operation: 原生 Binder 客户端/服务端</div><div class="line">op=&gt;operation: 原生 Binder 框架</div><div class="line">op1=&gt;operation: Binder 核心库</div><div class="line">op2=&gt;operation: Binder Adapter</div><div class="line">ProcessState.cpp/IPCThreadState.cpp</div><div class="line">op3=&gt;operation: Binder 驱动</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">st-&gt;op-&gt;op1-&gt;op2-&gt;op3</div></pre></td></tr></table></figure></p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><h3 id="应用层工作流程"><a href="#应用层工作流程" class="headerlink" title="应用层工作流程"></a>应用层工作流程</h3><ol>
<li>客户端首先获取服务端的代理对象<a href="代理对象实际上就是客户端简历一个服务端的“引用”，该对象具有服务端的功能，使其在客户端访问服务端的方法就像访问本地方法一样。">^footnote</a>。</li>
<li>客户端通过调用服务端代理的方式向服务端发送请求。</li>
<li>代理对象将用户请求通过Binder驱动发送到服务器进程。</li>
<li>服务器进程处理用户请求，并通过Binder驱动返回处理结果给客户端的服务端代理对象。</li>
<li>客户端收到服务端的返回结果。</li>
</ol>
<p>Binder 内存结构图:<br><img src="http://ww3.sinaimg.cn/bmiddle/7669bef3gw1ewjga6jqk8j20jh0nj790.jpg" alt="binder 内存结构图"></p>
<h3 id="系统层工作流程"><a href="#系统层工作流程" class="headerlink" title="系统层工作流程"></a>系统层工作流程</h3><p>具体Binder工作流程：</p>
<ol>
<li>Linux系统启动，Binder driver开始工作，注册设备文件/dev/binder</li>
<li>Android系统启动，ServiceManager开始工作，向Binder driver注册ContextManager，这个过程中，Binder driver中创建了第一个binder_node(注意：ServiceManager在内核空间有binder_node,但是在用户空间没有对应的BBinder）</li>
<li>Service进程启动，在用户空间创建了BBinder，并向ServiceManager注册服务，注册的过程中，Binder driver为Service在内核空间创建了binder_node</li>
<li>Client启动，向ServiceManager请求指定Serivce的Handle,这个过程中，Binder driver为Client在内核空间创建了handle对应的binder_ref</li>
<li>Client根据ServiceManager提供的handle,向Service请求服务</li>
</ol>
<h3 id="完整Binder工作流程"><a href="#完整Binder工作流程" class="headerlink" title="完整Binder工作流程"></a>完整Binder工作流程</h3><ol>
<li>Client进程在用户态调用BpBinder的接口</li>
<li>BpBinder调用ioctl向dev/binder文件写入数据，数据中包含自己的handle</li>
<li>进程进入到核心态，执行binder driver的代码，先查找handle关联的binder_ref</li>
<li>进一步根据binder_ref关联的binder_node,确定目标Service进程即(binder_proc)</li>
<li>把数据保存到目标进程（或目标线程）的todo队列，这时的数据中添加了当前线程（binder_thread)信息，并唤醒Service</li>
<li>Client开始等待回复</li>
<li>Service进程内的binder driver被唤醒，缓存client发送过来的数据</li>
<li>Service进程返回用户态，调用BBinder到接口，开始处理请求</li>
<li>请求处理结束，调用ioctl，回复Client的请求</li>
<li>进程进入核心态，通过步骤7缓存的数据，确定请求发起线程（步骤五中，数据内添加了请求发起线程的信息）</li>
<li>把回复数据保存到client进程请求线程的todo队列中，并唤醒Client进程中的请求线程</li>
<li>Service进程继续等待请求</li>
<li>Client进程内的请求线程被唤醒，返回用户态</li>
<li>返回到用户态，client进程处理回复数据</li>
</ol>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h4 id="Native-服务"><a href="#Native-服务" class="headerlink" title="Native 服务"></a>Native 服务</h4><blockquote>
<p>实际就是在C++空间完成的服务。主要指系统开始初始化时通过Init.rc脚本启动的服务。</p>
</blockquote>
<h4 id="Android-服务"><a href="#Android-服务" class="headerlink" title="Android 服务"></a>Android 服务</h4><blockquote>
<p>就是在JVM空间完成的服务，也使用Navite框架，但服务主体存在于Android空间。Android服务是在第二阶段Init2时简历的服务。</p>
</blockquote>
<h4 id="Init-空间服务"><a href="#Init-空间服务" class="headerlink" title="Init 空间服务"></a>Init 空间服务</h4><blockquote>
<p>主要用于完成属性设置，采用Sockey方式通信。</p>
</blockquote>
<h3 id="Binder-Adapter"><a href="#Binder-Adapter" class="headerlink" title="Binder Adapter"></a>Binder Adapter</h3><blockquote>
<p>实际上是对Binder驱动的封装，用于完成Binder库与Binder 内核驱动的交互。主要实现包括：IPCThreadState和ProcessState。</p>
</blockquote>
<p>PorcessState：包含通信细节，利用open_binder打开Linux设备dev\binder。通过ioctrl建立基本的通信框架。<br>IPCThreadState：主要负责Binder数据读取、写入和请求处理框架。<br>每个进程只有一个ProcessState对象。<br>每个线程都会有一个IPCThreadState对象。</p>
<h4 id="PorcessState"><a href="#PorcessState" class="headerlink" title="PorcessState"></a>PorcessState</h4><blockquote>
<p>ProcessState的作用是维护当前进程中所有Service代理（BpBinder对象）。一个客户端进程可能需要多个Service的服务，这样可能会创建多个Service代理（BpBinder对象），客户端进程中的ProcessState对象将会负责维护这些Service代理。</p>
</blockquote>
<p>ProcessState负责打开/driver/binder并将句柄记录在变量中。真正使用Binder设备句柄的是IPCThreadState。</p>
<h4 id="IPCThreadState"><a href="#IPCThreadState" class="headerlink" title="IPCThreadState"></a>IPCThreadState</h4><p>有三个重要的函数功能。</p>
<ol>
<li>talkWithDriver() 负责读取和写入功能</li>
<li>executeCommand() 负责处理请求功能</li>
<li>joinThreadPool() 负责循环结构</li>
</ol>
<p>不管是客户端进程还是服务端进程，都需要IPCThreadState来与Binder设备通信。<br>客户端：通过服务代理对象BpBinder调用transact函数把请求写入Binder。<br>服务端：完成初始化后就进入循环状态等待客户端请求，Service进程调用它的IPCThreadState对象的joinThreadPool方法轮询Binder设备。</p>
<h4 id="BBinder"><a href="#BBinder" class="headerlink" title="BBinder"></a>BBinder</h4><p>BBinder是server端用于接收消息的通道。<br>transact方法:<br>当IPCThreadState实例收到BD消息时，通过BBinder的transact的方法将其传递给它的子类BnSERVICE的onTransact函数执行server端的操作。</p>
<h4 id="BpBinder"><a href="#BpBinder" class="headerlink" title="BpBinder"></a>BpBinder</h4><p>BpBinder是client端创建的用于消息发送的代理。主要功能是负责client向BD发送调用请求的数据。<br>transact方法:<br>向IPCThreadState实例发送消息，通知其有消息要发送给BD。</p>
<h2 id="Binder-内存管理"><a href="#Binder-内存管理" class="headerlink" title="Binder 内存管理"></a>Binder 内存管理</h2><h3 id="传统-IPC-方式"><a href="#传统-IPC-方式" class="headerlink" title="传统 IPC 方式"></a>传统 IPC 方式</h3><p>在传统的IPC方式中，数据从发送端到达接收端通常的做法是，发送方将准备好的数据存放在缓存区中，调用API通过系统调用进入内核中。内核服务程序在内核空间分配内存，将数据从发送方缓存区复制到内核缓存区中。接收方读数据时也要提供一块缓存区，内核将数据从内核缓存区拷贝到接收方提供的缓存区中并唤醒接收线程，完成一次数据发送。这种存储-转发机制有两个缺陷：首先是效率低下，需要做两次拷贝：用户空间-&gt;内核空间-&gt;用户空间。Linux使用copy_from_user()和copy_to_user()实现这两个跨空间拷贝，在此过程中如果使用了高端内存（high memory），这种拷贝需要临时建立/取消页面映射，造成性能损失。其次是接收数据的缓存要由接收方提供，可接收方不知道到底要多大的缓存才够用，只能开辟尽量大的空间或先调用API接收消息头获得消息体大小，再开辟适当的空间接收消息体。两种做法都有不足，不是浪费空间就是浪费时间。</p>
<h3 id="Binder-方式"><a href="#Binder-方式" class="headerlink" title="Binder 方式"></a>Binder 方式</h3><p><strong>Binder采用一种全新策略：由Binder驱动负责管理数据接收缓存。</strong>我们注意到Binder驱动实现了mmap()系统调用，这对字符设备是比较特殊的，因为mmap()通常用在有物理存储介质的文件系统上，而象Binder这样没有物理介质，纯粹用来通信的字符设备没必要支持mmap()。Binder驱动当然不是为了在物理介质和用户空间做映射，而是用来创建数据接收的缓存空间。先看mmap()是如何使用的：<br>fd = open(“/dev/binder”, O_RDWR);<br>mmap(NULL, MAP_SIZE, PROT_READ, MAP_PRIVATE, fd, 0);<br>这样Binder的接收方就有了一片大小为MAP_SIZE的接收缓存区。mmap()的返回值是内存映射在用户空间的地址，不过这段空间是由驱动管理，用户不必也不能直接访问（映射类型为PROT_READ，只读映射）。</p>
<p>接收缓存区映射好后就可以做为缓存池接收和存放数据了。前面说过，接收数据包的结构为binder_transaction_data，但这只是消息头，真正的有效负荷位于data.buffer所指向的内存中。这片内存不需要接收方提供，恰恰是来自mmap()映射的这片缓存池。在数据从发送方向接收方拷贝时，驱动会根据发送数据包的大小，使用最佳匹配算法从缓存池中找到一块大小合适的空间，将数据从发送缓存区复制过来。要注意的是，存放binder_transaction_data结构本身以及表4中所有消息的内存空间还是得由接收者提供，但这些数据大小固定，数量也不多，不会给接收方造成不便。映射的缓存池要足够大，因为接收方的线程池可能会同时处理多条并发的交互，每条交互都需要从缓存池中获取目的存储区，一旦缓存池耗竭将产生导致无法预期的后果。</p>
<p>有分配必然有释放。接收方在处理完数据包后，就要通知驱动释放data.buffer所指向的内存区。在介绍Binder协议时已经提到，这是由命令BC_FREE_BUFFER完成的。</p>
<p>通过上面介绍可以看到，驱动为接收方分担了最为繁琐的任务：分配/释放大小不等，难以预测的有效负荷缓存区，而接收方只需要提供缓存来存放大小固定，最大空间可以预测的消息头即可。在效率上，由于mmap()分配的内存是映射在接收方用户空间里的，所有总体效果就相当于对有效负荷数据做了一次从发送方用户空间到接收方用户空间的直接数据拷贝，省去了内核中暂存这个步骤，提升了一倍的性能。顺便再提一点，Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用copy_from_user()拷贝到内核空间，再用copy_to_user()拷贝到另一个用户空间。为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/18/Android-浅析-Binder-机制-基础-三/" data-id="civ9405rs0006akqt40oar9r6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-Binder-机制-基础-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/18/Android-浅析-Binder-机制-基础-二/" class="article-date">
  <time datetime="2016-09-18T08:39:39.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/Android-浅析-Binder-机制-基础-二/">Android 浅析 Binder 机制 基础 (二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Binder是一个进程间通信的机制，实质就是把对象从一个进程映射到另一个进程中。</p>
</blockquote>
<p>它主要能提供的功能：<br>1：用驱动程序来推进进程间的通信。<br>2：通过共享内存来提高性能。<br>3：位进程请求分配每个进程的线程池。<br>4：针对系统中的对象引入引用计数和跨进程的对象引用映射。<br>5：进程间同步调用。<br>最后为什么它那么重要，因为Android系统的运行都将依赖Binder驱动。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><blockquote>
<p>一个Binder服务器端就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用于接收binder驱动发送的信息，收到消息后，会执行相关的服务代码。</p>
</blockquote>
<p>做为Proxy设计模式的基础，首先定义一个抽象接口类封装Server所有功能，其中包含一系列纯虚函数留待Server和Proxy各自实现。由于这些函数需要跨进程调用，须为其一一编号，从而Server可以根据收到的编号决定调用哪个函数。其次就要引入Binder了。Server端定义另一个Binder抽象类处理来自Client的Binder请求数据包，其中最重要的成员是虚函数onTransact()。该函数分析收到的数据包，调用相应的接口函数处理请求。</p>
<p>接下来采用继承方式以接口类和Binder抽象类为基类构建Binder在Server中的实体，实现基类里所有的虚函数，包括公共接口函数以及数据包处理函数：onTransact()。这个函数的输入是来自Client的binder_transaction_data结构的数据包。前面提到，该结构里有个成员code，包含这次请求的接口函数编号。onTransact()将case-by-case地解析code值，从数据包里取出函数参数，调用接口类中相应的，已经实现的公共接口函数。函数执行完毕，如果需要返回数据就再构建一个binder_transaction_data包将返回数据包填入其中。</p>
<p>那么各个Binder实体的onTransact()又是什么时候调用呢？这就需要驱动参与了。前面说过，Binder实体须要以Binde传输结构flat_binder_object形式发送给其它进程才能建立Binder通信，而Binder实体指针就存放在该结构的handle域中。驱动根据Binder位置数组从传输数据中获取该Binder的传输结构，为它创建位于内核中的Binder节点，将Binder实体指针记录在该节点中。如果接下来有其它进程向该Binder发送数据，驱动会根据节点中记录的信息将Binder实体指针填入binder_transaction_data的target.ptr中返回给接收线程。接收线程从数据包中取出该指针，reinterpret_cast成Binder抽象类并调用onTransact()函数。由于这是个虚函数，不同的Binder实体中有各自的实现，从而可以调用到不同Binder实体提供的onTransact()。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><blockquote>
<p>客户端要想访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binder对象的服务了。</p>
</blockquote>
<p>做为Proxy设计模式的一部分，Client端的Binder同样要继承Server提供的公共接口类并实现公共函数。但这不是真正的实现，而是对远程函数调用的包装：将函数参数打包，通过Binder向Server发送申请并等待返回值。为此Client端的Binder还要知道Binder实体的相关信息，即对Binder实体的引用。该引用或是由SMgr转发过来的，对实名Binder的引用或是由另一个进程直接发送过来的，对匿名Binder的引用。</p>
<p>由于继承了同样的公共接口类，Client Binder提供了与Server Binder一样的函数原型，使用户感觉不出Server是运行在本地还是远端。Client Binder中，公共接口函数的包装方式是：创建一个binder_transaction_data数据包，将其对应的编码填入code域，将调用该函数所需的参数填入data.buffer指向的缓存中，并指明数据包的目的地，那就是已经获得的对Binder实体的引用，填入数据包的target.handle中。注意这里和Server的区别：实际上target域是个联合体，包括ptr和handle两个成员，前者用于接收数据包的Server，指向 Binder实体对应的内存空间；后者用于作为请求方的Client，存放Binder实体的引用，告知驱动数据包将路由给哪个实体。数据包准备好后，通过驱动接口发送出去。经过BC_TRANSACTION/BC_REPLY回合完成函数的远程调用并得到返回值。</p>
<h2 id="驱动层"><a href="#驱动层" class="headerlink" title="驱动层"></a>驱动层</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Binder采用AIDL来描述进程间的接口。<br>主要方法：<br>1、binder_ioctl:驱动与用户空间进程交换数据。<br>2、binder_thread_write:发送请求或返回结果。<br>3、binder_thread_read:读取结果。<br>4、binder_transaction:转发请求并返回结果。<br>5、binder_parse:数据的解析。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="主要数据结构体"><a href="#主要数据结构体" class="headerlink" title="主要数据结构体"></a>主要数据结构体</h4><p>1、binder_work<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_work &#123;</div><div class="line">    <span class="keyword">struct</span> list_head entry;</div><div class="line">    <span class="keyword">enum</span> &#123;</div><div class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,</div><div class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</div><div class="line">        BINDER_WORK_NODE,</div><div class="line">        BINDER_WORK_DEAD_BINDER,</div><div class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</div><div class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</div><div class="line">    &#125; type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>2、Binder类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    <span class="comment">//本地对象</span></div><div class="line">    BINDER_TYPE_BINDER  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    <span class="comment">//远程对象“引用”</span></div><div class="line">    BINDER_TYPE_HANDLE  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    <span class="comment">//文件</span></div><div class="line">    BINDER_TYPE_FD      = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>3、传输方式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> transaction_flags &#123;</div><div class="line">    TF_ONE_WAY  = <span class="number">0x01</span>, <span class="comment">/* this is a one-way call: async, no return */</span></div><div class="line">    TF_ROOT_OBJECT  = <span class="number">0x04</span>, <span class="comment">/* contents are the component's root object */</span></div><div class="line">    TF_STATUS_CODE  = <span class="number">0x08</span>, <span class="comment">/* contents are a 32-bit status code */</span></div><div class="line">    TF_ACCEPT_FDS   = <span class="number">0x10</span>, <span class="comment">/* allow replies with file descriptors */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>4、Binder对象<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * This is the flattened representation of a Binder object for transfer</div><div class="line"> * between processes.  The 'offsets' supplied as part of a binder transaction</div><div class="line"> * contains offsets into the data where these structures occur.  The Binder</div><div class="line"> * driver takes care of re-writing the structure type and data as it moves</div><div class="line"> * between processes.</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> flat_binder_object &#123;</div><div class="line">    <span class="comment">/* 8 bytes for large_flat_header. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       type; <span class="comment">//Binder类型</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags; <span class="comment">//传输方式</span></div><div class="line"></div><div class="line">    <span class="comment">/* 8 bytes of data. */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span>        *binder;    <span class="comment">/* local object */</span></div><div class="line">        <span class="keyword">signed</span> <span class="keyword">long</span> handle;     <span class="comment">/* remote object */</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/* extra data associated with local object */</span></div><div class="line">    <span class="keyword">void</span>            *cookie;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>5、Binder实际内容的结构体<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_transaction_data &#123;</div><div class="line">    <span class="comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span></div><div class="line">     * identifying the target and contents of the transaction.</div><div class="line">     */</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">size_t</span>  handle; <span class="comment">/* target descriptor of command transaction */</span></div><div class="line">        <span class="keyword">void</span>    *ptr;   <span class="comment">/* target descriptor of return transaction */</span></div><div class="line">    &#125; target;</div><div class="line">    <span class="keyword">void</span>        *cookie;    <span class="comment">/* target object cookie */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;       <span class="comment">/* transaction command */</span></div><div class="line"></div><div class="line">    <span class="comment">/* General information about the transaction. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    <span class="keyword">pid_t</span>       sender_pid;</div><div class="line">    <span class="keyword">uid_t</span>       sender_euid;</div><div class="line">    <span class="keyword">size_t</span>      data_size;  <span class="comment">/* number of bytes of data */</span></div><div class="line">    <span class="keyword">size_t</span>      offsets_size;   <span class="comment">/* number of bytes of offsets */</span></div><div class="line"></div><div class="line">    <span class="comment">/* If this transaction is inline, the data immediately</span></div><div class="line">     * follows here; otherwise, it ends with a pointer to</div><div class="line">     * the data buffer.</div><div class="line">     */</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">/* transaction data */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *buffer;</div><div class="line">            <span class="comment">/* offsets from buffer to flat_binder_object structs */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *offsets;</div><div class="line">        &#125; ptr;</div><div class="line">        <span class="keyword">uint8_t</span> buf[<span class="number">8</span>];</div><div class="line">    &#125; data;<span class="comment">//真正的数据</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>6、binder_write_read<br>作用：当Binder驱动找到处理此事件的进程后，就会把需要处理的时间的任务放在读缓冲(binder_write_read)里，返回给这个服务线程，该服务线程则会执行指定命令的操作。处理请求的线程把数据交给合适的对象来执行预定操作，然后把返回结果同样用binder_transaction_data结构封装，以写命令的方式传回Binder，并将此数据放在一个读缓冲(binder_write_read)里，返回给正在等待结果的原线程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_write_read &#123;</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; <span class="comment">/* bytes to write */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_consumed; <span class="comment">/* bytes consumed by driver */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   write_buffer;</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;  <span class="comment">/* bytes to read */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;  <span class="comment">/* bytes consumed by driver */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   read_buffer;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>7、binder_proc<br>用于保存调用Binder的各个进程或线程的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_proc &#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node proc_node;</div><div class="line">    <span class="keyword">struct</span> rb_root threads;</div><div class="line">    <span class="keyword">struct</span> rb_root nodes;</div><div class="line">    <span class="keyword">struct</span> rb_root refs_by_desc;</div><div class="line">    <span class="keyword">struct</span> rb_root refs_by_node;</div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line">    <span class="keyword">struct</span> vm_area_struct *vma;</div><div class="line">    <span class="keyword">struct</span> task_struct *tsk;</div><div class="line">    <span class="keyword">struct</span> files_struct *files;</div><div class="line">    <span class="keyword">struct</span> hlist_node deferred_work_node;</div><div class="line">    <span class="keyword">int</span> deferred_work;</div><div class="line">    <span class="keyword">void</span> *buffer;</div><div class="line">    <span class="keyword">ptrdiff_t</span> user_buffer_offset;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> list_head buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root free_buffers;</div><div class="line">    <span class="keyword">struct</span> rb_root allocated_buffers;</div><div class="line">    <span class="keyword">size_t</span> free_async_space;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> page **pages;</div><div class="line">    <span class="keyword">size_t</span> buffer_size;</div><div class="line">    <span class="keyword">uint32_t</span> buffer_free;</div><div class="line">    <span class="keyword">struct</span> list_head todo;</div><div class="line">    <span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">    <span class="keyword">struct</span> binder_stats stats;</div><div class="line">    <span class="keyword">struct</span> list_head delivered_death;</div><div class="line">    <span class="keyword">int</span> max_threads;</div><div class="line">    <span class="keyword">int</span> requested_threads;</div><div class="line">    <span class="keyword">int</span> requested_threads_started;</div><div class="line">    <span class="keyword">int</span> ready_threads;</div><div class="line">    <span class="keyword">long</span> default_priority;</div><div class="line">    <span class="keyword">struct</span> dentry *debugfs_entry;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>8、binder_node<br>Binder节点。(略)<br>9、binder_thread<br>存储每一个单独的线程的信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_thread &#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc;<span class="comment">//当前线程属于哪一个Binder进程</span></div><div class="line">    <span class="keyword">struct</span> rb_node rb_node;</div><div class="line">    <span class="keyword">int</span> pid;</div><div class="line">    <span class="keyword">int</span> looper;<span class="comment">//线程状态信息</span></div><div class="line">    <span class="keyword">struct</span> binder_transaction *transaction_stack;<span class="comment">//接收和发送的进程和线程信息</span></div><div class="line">    <span class="keyword">struct</span> list_head todo;</div><div class="line">    <span class="keyword">uint32_t</span> return_error; <span class="comment">/* Write failed, return error code in read buf */</span></div><div class="line">    <span class="keyword">uint32_t</span> return_error2; <span class="comment">/* Write failed, return error code in read */</span></div><div class="line">        <span class="comment">/* buffer. Used when sending a reply to a dead process that */</span></div><div class="line">        <span class="comment">/* we are also waiting on */</span></div><div class="line">    <span class="keyword">wait_queue_head_t</span> wait;</div><div class="line">    <span class="keyword">struct</span> binder_stats stats;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> binder_stats &#123;</div><div class="line">    <span class="keyword">int</span> br[_IOC_NR(BR_FAILED_REPLY) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> bc[_IOC_NR(BC_DEAD_BINDER_DONE) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> obj_created[BINDER_STAT_COUNT];</div><div class="line">    <span class="keyword">int</span> obj_deleted[BINDER_STAT_COUNT];</div><div class="line">&#125;;</div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    BINDER_LOOPER_STATE_REGISTERED  = <span class="number">0x01</span>,</div><div class="line">    BINDER_LOOPER_STATE_ENTERED     = <span class="number">0x02</span>,</div><div class="line">    BINDER_LOOPER_STATE_EXITED      = <span class="number">0x04</span>,</div><div class="line">    BINDER_LOOPER_STATE_INVALID     = <span class="number">0x08</span>,</div><div class="line">    BINDER_LOOPER_STATE_WAITING     = <span class="number">0x10</span>,</div><div class="line">    BINDER_LOOPER_STATE_NEED_RETURN = <span class="number">0x20</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>10、binder_transaction<br>中转请求和返回结果，保存接收和要发送的进程信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> binder_transaction &#123;</div><div class="line">    <span class="keyword">int</span> debug_id;</div><div class="line">    <span class="keyword">struct</span> binder_work work;</div><div class="line">    <span class="keyword">struct</span> binder_thread *from;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *from_parent;</div><div class="line">    <span class="keyword">struct</span> binder_proc *to_proc;</div><div class="line">    <span class="keyword">struct</span> binder_thread *to_thread;</div><div class="line">    <span class="keyword">struct</span> binder_transaction *to_parent;</div><div class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</div><div class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    <span class="keyword">long</span>    priority;</div><div class="line">    <span class="keyword">long</span>    saved_priority;</div><div class="line">    <span class="keyword">uid_t</span>   sender_euid;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>11、binder_buffer<br>表示binder的缓冲区信息。(略)</p>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p>1、binder_init<br>Binder驱动初始化函数，一般需要设备驱动接口调用。Android Binder设备驱动接口函数是device_initcall，目的是不让Binder驱动支持动态编译，而且需要内核做镜像。<br>misc_register注册自己为一个Misc设备，节点位于/dev/binder。创建只读proc文件：1./proc/binder/state;2./proc/binder/stats;3./proc/binder/transactions;4./proc/binder/transaction_log;5./proc/binder/failed_transaction_log;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//操作设备文件(/dev/binder)的接口</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations binder_fops = &#123;</div><div class="line">    .owner = THIS_MODULE,</div><div class="line">    .poll = binder_poll,</div><div class="line">    .unlocked_ioctl = binder_ioctl,</div><div class="line">    .mmap = binder_mmap,</div><div class="line">    .open = binder_open,</div><div class="line">    .flush = binder_flush,</div><div class="line">    .release = binder_release,</div><div class="line">&#125;;</div><div class="line"><span class="comment">//Misc设备信息</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice binder_miscdev = &#123;</div><div class="line">    .minor = MISC_DYNAMIC_MINOR,</div><div class="line">    .name = <span class="string">"binder"</span>,</div><div class="line">    .fops = &amp;binder_fops</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">"binder"</span>);</div><div class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">    binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">"binder"</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root)</div><div class="line">        binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">"proc"</span>, binder_debugfs_dir_entry_root);</div><div class="line">    ret = misc_register(&amp;binder_miscdev);</div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</div><div class="line">        debugfs_create_file(<span class="string">"state"</span>, S_IRUGO, binder_debugfs_dir_entry_root, <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_state_fops);</div><div class="line">        debugfs_create_file(<span class="string">"stats"</span>, S_IRUGO, binder_debugfs_dir_entry_root, <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_stats_fops);</div><div class="line">        debugfs_create_file(<span class="string">"transactions"</span>, S_IRUGO, binder_debugfs_dir_entry_root, <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_transactions_fops);</div><div class="line">        debugfs_create_file(<span class="string">"transaction_log"</span>, S_IRUGO, binder_debugfs_dir_entry_root,</div><div class="line">                    &amp;binder_transaction_log,</div><div class="line">                    &amp;binder_transaction_log_fops);</div><div class="line">        debugfs_create_file(<span class="string">"failed_transaction_log"</span>, S_IRUGO, binder_debugfs_dir_entry_root,</div><div class="line">                    &amp;binder_transaction_log_failed,</div><div class="line">                    &amp;binder_transaction_log_fops);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、binder_open<br>打开Binder设备文件/dev/binder。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc;</div><div class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    get_task_struct(current);</div><div class="line">    proc-&gt;tsk = current;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</div><div class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</div><div class="line">    proc-&gt;default_priority = task_nice(current);</div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    binder_stats_created(BINDER_STAT_PROC);</div><div class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</div><div class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</div><div class="line">    filp-&gt;private_data = proc;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</div><div class="line">        <span class="keyword">char</span> strbuf[<span class="number">11</span>];</div><div class="line">        <span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, proc-&gt;pid);</div><div class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,</div><div class="line">            binder_debugfs_dir_entry_proc, proc, &amp;binder_proc_fops);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、binder_release<br>释放在打开以及其他操作过程中分配的空间并清理相关数据信息。binder_defer_work执行的操作比较复杂，采用了延迟执行的方法来提高系统的响应速度和性能。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_release</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    debugfs_remove(proc-&gt;debugfs_entry);</div><div class="line">    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4、binder_flush<br>在关闭一个设备文件描述符复制时被调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_flush</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">fl_owner_t</span> id)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    binder_defer_work(proc, BINDER_DEFERRED_FLUSH);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、binder_poll<br>非阻塞型IO内核驱动函数。仅支持设备是否可以飞阻塞地读(POLLIN)，有两种等待任务：proc_work和thread_work。最后都是调用poll_wait函数实现poll操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">binder_poll</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span></div><div class="line">                <span class="keyword">struct</span> poll_table_struct *wait)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">struct</span> binder_thread *thread = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> wait_for_proc_work;</div><div class="line"></div><div class="line">    mutex_lock(&amp;binder_lock);</div><div class="line">    thread = binder_get_thread(proc);</div><div class="line"></div><div class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</div><div class="line">        list_empty(&amp;thread-&gt;todo) &amp;&amp; thread-&gt;return_error == BR_OK;</div><div class="line">    mutex_unlock(&amp;binder_lock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</div><div class="line">        <span class="keyword">if</span> (binder_has_proc_work(proc, thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">        poll_wait(filp, &amp;proc-&gt;wait, wait);</div><div class="line">        <span class="keyword">if</span> (binder_has_proc_work(proc, thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (binder_has_thread_work(thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">        poll_wait(filp, &amp;thread-&gt;wait, wait);</div><div class="line">        <span class="keyword">if</span> (binder_has_thread_work(thread))</div><div class="line">            <span class="keyword">return</span> POLLIN;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6、binder_get_thread<br>在threads队列中查找当前的进程信息。(略)<br>7、binder_mmap<br>mmap（memory map）用于把设备内存映射到用户进程地址空间中，就可以像操作用户内存那样操作设备内存。<br>由于设备内存是在mmap操作中分配的，每个进程或线程只能执行一次映射操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="keyword">struct</span> vm_struct *area;</div><div class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</div><div class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</div><div class="line">    <span class="comment">//检测映射内存的大小</span></div><div class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</div><div class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</div><div class="line">    <span class="comment">//检测flags</span></div><div class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</div><div class="line">        ret = -EPERM;</div><div class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</div><div class="line">        <span class="keyword">goto</span> err_bad_arg;</div><div class="line">    &#125;</div><div class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</div><div class="line">    <span class="comment">//判断是否已经映射过</span></div><div class="line">    <span class="keyword">if</span> (proc-&gt;buffer) &#123;</div><div class="line">        ret = -EBUSY;</div><div class="line">        failure_string = <span class="string">"already mapped"</span>;</div><div class="line">        <span class="keyword">goto</span> err_already_mapped;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//申请虚拟空间</span></div><div class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</div><div class="line">    <span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"get_vm_area"</span>;</div><div class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</div><div class="line">    &#125;</div><div class="line">    proc-&gt;buffer = area-&gt;addr;</div><div class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPU_CACHE_VIPT</span></div><div class="line">    <span class="keyword">if</span> (cache_is_vipt_aliasing()) &#123;</div><div class="line">        <span class="keyword">while</span> (CACHE_COLOUR((vma-&gt;vm_start ^ (<span class="keyword">uint32_t</span>)proc-&gt;buffer))) &#123;</div><div class="line">            vma-&gt;vm_start += PAGE_SIZE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc page array"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</div><div class="line">    &#125;</div><div class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</div><div class="line"></div><div class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</div><div class="line">    vma-&gt;vm_private_data = proc;</div><div class="line">    <span class="comment">//分配pages空间</span></div><div class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc small buf"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</div><div class="line">    &#125;</div><div class="line">    buffer = proc-&gt;buffer;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;buffers);</div><div class="line">    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    binder_insert_free_buffer(proc, buffer);</div><div class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</div><div class="line">    barrier();</div><div class="line">    proc-&gt;files = get_files_struct(current);</div><div class="line">    proc-&gt;vma = vma;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">err_alloc_small_buf_failed:</div><div class="line">    kfree(proc-&gt;pages);</div><div class="line">    proc-&gt;pages = <span class="literal">NULL</span>;</div><div class="line">err_alloc_pages_failed:</div><div class="line">    vfree(proc-&gt;buffer);</div><div class="line">    proc-&gt;buffer = <span class="literal">NULL</span>;</div><div class="line">err_get_vm_area_failed:</div><div class="line">err_already_mapped:</div><div class="line">err_bad_arg:</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤总结：<br>1：检查内存映射条件。<br>2：获取地址空间，并把次空间的地址记录在进程信息（buffer）中。<br>3：分配物理页面并记录下来。<br>4：将buffer插入到进程信息的buffer列表中。<br>5：调用binder_update_page_range函数将分配的物理页面和vm空间对应起来。<br>6：通过binder_insert_free_buffer函数把此进程的buffer插入到进程信息中。<br><strong>8、binder_ioctl</strong><br>Binder的ioctl命令：<br>1：首先检查数据是否完整。<br>2：从用户空间复制数据到binder_write_read结构体重。<br>3：通过write_size 和 bwr.read_size判断需要执行的操作。<br>最终的操作是inder_thread_write和binder_thread_read函数实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ           _IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_TIMEOUT     _IOW(<span class="meta-string">'b'</span>, 3, int64_t)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS      _IOW(<span class="meta-string">'b'</span>, 5, size_t)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_PRIORITY    _IOW(<span class="meta-string">'b'</span>, 6, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR      _IOW(<span class="meta-string">'b'</span>, 7, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT      _IOW(<span class="meta-string">'b'</span>, 8, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION          _IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></div></pre></td></tr></table></figure></p>
<p>核心是BINDER_WRITE_READ：<br>IPC机制就是通过此接口实现。读代码吧！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> binder_write_read bwr;</div><div class="line">  <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</div><div class="line">    ret = -EINVAL;</div><div class="line">    <span class="keyword">goto</span> err;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">    ret = -EFAULT;</div><div class="line">    <span class="keyword">goto</span> err;</div><div class="line">  &#125;</div><div class="line">  binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">         <span class="string">"binder: %d:%d write %ld at %08lx, read %ld at %08lx\n"</span>,</div><div class="line">         proc-&gt;pid, thread-&gt;pid, bwr.write_size, bwr.write_buffer,</div><div class="line">         bwr.read_size, bwr.read_buffer);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</div><div class="line">    ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">      bwr.read_consumed = <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">        ret = -EFAULT;</div><div class="line">      <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</div><div class="line">    ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</div><div class="line">    <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</div><div class="line">      wake_up_interruptible(&amp;proc-&gt;wait);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">        ret = -EFAULT;</div><div class="line">      <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  binder_debug(BINDER_DEBUG_READ_WRITE,</div><div class="line">         <span class="string">"binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n"</span>,</div><div class="line">         proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,</div><div class="line">         bwr.read_consumed, bwr.read_size);</div><div class="line">  <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">    ret = -EFAULT;</div><div class="line">    <span class="keyword">goto</span> err;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h2><blockquote>
<p>主要负责管理Android系统中所有的服务。对于客户端，要与服务端进行通信时，首先要通过它来查询和取得所需要交互的服务。对于服务端，创建的同时就要向ServiceManager注册自己提供的服务，以便客户端能够进行查询和获取。</p>
</blockquote>
<p>因为这个篇章重点在于Binder，所以更多ServiceManager细节在浅析ServiceManager篇章里讲解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/18/Android-浅析-Binder-机制-基础-二/" data-id="civ9405rs0007akqtbt95esbp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-Binder-机制-基础-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/18/Android-浅析-Binder-机制-基础-一/" class="article-date">
  <time datetime="2016-09-18T08:18:12.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/Android-浅析-Binder-机制-基础-一/">Android 浅析 Binder 机制 基础 (一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<p>Dianne Hackborn 记住这家伙，这系统他做的。</p>
<h2 id="Binder-简要"><a href="#Binder-简要" class="headerlink" title="Binder 简要"></a>Binder 简要</h2><p>Binder：用来实现不用进程间通信。Binder属于一个驱动，工作在linux层，运行在kernel。服务端，客户端处在用户空间，binder驱动处在内核空间。<br><img src="http://ww3.sinaimg.cn/mw1024/7669bef3gw1ewj4l8x7olj20fe0aezlf.jpg" alt="binder"></p>
<p>Binder机制有两个重要的类：IBinder和Binder。通过分析这两个主要的类来浅析Binder的使用。</p>
<h2 id="IBinder"><a href="#IBinder" class="headerlink" title="IBinder"></a>IBinder</h2><blockquote>
<p>Base interface for a remotable object, the core part of a lightweight remote procedure call mechanism designed for high performance when performing in-process and cross-process calls. This interface describes the abstract protocol for interacting with a remotable object.  Do not implement this interface directly, instead extend from Binder.<br>翻译：<br>一个远程对象的基本接口，一个轻量级的远程程序的调用机制的核心部分专为高性能设计在执行程序和跨进程调用。该接口描述了与远程对象交互的抽象协议。注意：不要直接实现这个接口，而不是从“Binder”中扩展。</p>
</blockquote>
<p>IBinder的核心API是transact transact()匹配在Binder类的onTransact Binder.onTransact()函数中。这方法允许你发送一个调用到一个IBinder对象和从IBinder对象中收到一个调用。这个API是同步的。</p>
<p>通过transact()传输的数据是一个Parcel，一个通用的缓存数据，同时也有一些元数据。在buffer中元数据使用来管理IBinder对象标记的，这样的引用可以在buffer穿越过程中得以保留。这种机制确保IBinder被写入Parcel发送到另一个进程，如果其他进程发送一个标记到同一个IBinder回到原来的过程，那么原始的过程中会接收到同一个IBinder对象回来。这些语义允许IBinder/Binder对象作为一个独特的身份（作为一个记号或作其他用途），可以在过程管理。</p>
<p>The system maintains a pool of transaction threads in each process that it runs in.  These threads are used to dispatch all IPCs coming in from other processes. </p>
<p>The Binder system also supports recursion across processes.</p>
<h3 id="1-1、transact-方法"><a href="#1-1、transact-方法" class="headerlink" title="1.1、transact()方法"></a>1.1、transact()方法</h3><ul>
<li><p>IBinder核心接口方法：</p>
<ul>
<li>允许你可以分别发送一个消息到一个Binder对象和接收一个从Binder对象发出的消息。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">Perform a generic operation with the object.</div><div class="line"></div><div class="line">@param code The action to perform.  This should be a number between FIRST_CALL_TRANSACTION and LAST_CALL_TRANSACTION.</div><div class="line">@param data Marshalled data to send to the target.  Must not be null. If you are not sending any data, you must create an empty Parcel that is given here.</div><div class="line">@param reply Marshalled data to be received from the target. May be null if you are not interested in the return value.</div><div class="line">@param flags Additional operation flags.  Either 0 for a normal RPC, or FLAG_ONEWAY for a one-way RPC.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>确认远程对象是否有效有三个方法：</p>
<ul>
<li>The transact(); 如果对象被销毁而你尝试去调用这个函数，它会抛出一个异常。</li>
<li>The pingBinder(); 如果对象被销毁，它会返回false。</li>
<li>The linkToDeath(); 用来注册一个DeathRecipient，当被销毁的时候将会监听到。</li>
</ul>
</li>
</ul>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><blockquote>
<p>Base class for a remotable object, the core part of a lightweight remote procedure call mechanism defined by IBinder. This class is an implementation of IBinder that provides standard local implementation of such an object.<br>翻译：<br>基类可远程对象，由定义的IBinder一个轻量级的远程过程调用机制的核心组成部分。这个类是的IBinder的实现，提供了标准的地方实现这样一个目标的。</p>
</blockquote>
<p>大多数开发者不应该直接实现这个类，作为代替应该使用AIDl工具去描述你想要的接口，产生合适的Binder子类。但是，你可以直接使用Binder来实现自定义的RPC协议或简单地实例化一个Binder的对象来直接使用作为一个记号可以共享的过程。</p>
<h3 id="transact-方法"><a href="#transact-方法" class="headerlink" title="transact()方法"></a>transact()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**Default implementation rewinds the parcels and calls onTransact.  On the remote side, transact calls into the binder to do the IPC.*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span></span></div><div class="line">        <span class="keyword">int</span> flags) <span class="keyword">throws</span> RemoteException &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"Binder"</span>, <span class="string">"Transact: "</span> + code + <span class="string">" to "</span> + <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</div><div class="line">        data.setDataPosition(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span> r = onTransact(code, data, reply, flags);</div><div class="line">    <span class="keyword">if</span> (reply != <span class="keyword">null</span>) &#123;</div><div class="line">        reply.setDataPosition(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="onTransact-方法"><a href="#onTransact-方法" class="headerlink" title="onTransact()方法"></a>onTransact()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*Default implementation is a stub that returns false.  You will want to override this to do the appropriate unmarshalling of transactions. If you want to call this, call transact().*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span></span></div><div class="line">        <span class="keyword">int</span> flags) <span class="keyword">throws</span> RemoteException &#123;</div><div class="line">    <span class="keyword">if</span> (code == INTERFACE_TRANSACTION) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code == DUMP_TRANSACTION) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="execTransact-方法"><a href="#execTransact-方法" class="headerlink" title="execTransact()方法"></a>execTransact()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Entry point from android_util_Binder.cpp's onTransact</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj,</span></span></div><div class="line">        <span class="keyword">int</span> flags) &#123;</div><div class="line">    Parcel data = Parcel.obtain(dataObj);</div><div class="line">    Parcel reply = Parcel.obtain(replyObj);</div><div class="line">    <span class="comment">// theoretically, we should call transact, which will call onTransact,</span></div><div class="line">    <span class="comment">// but all that does is rewind it, and we just got these from an IPC,</span></div><div class="line">    <span class="comment">// so we'll just call it directly.</span></div><div class="line">    <span class="keyword">boolean</span> res;</div><div class="line">    <span class="comment">// Log any exceptions as warnings, don't silently suppress them.</span></div><div class="line">    <span class="comment">// If the call was FLAG_ONEWAY then these exceptions disappear into the ether.</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        res = onTransact(code, data, reply, flags);</div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="keyword">if</span> ((flags &amp; FLAG_ONEWAY) != <span class="number">0</span>) &#123;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            reply.setDataPosition(<span class="number">0</span>);</div><div class="line">            reply.writeException(e);</div><div class="line">        &#125;</div><div class="line">        res = <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">        <span class="keyword">if</span> ((flags &amp; FLAG_ONEWAY) != <span class="number">0</span>) &#123;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            reply.setDataPosition(<span class="number">0</span>);</div><div class="line">            reply.writeException(e);</div><div class="line">        &#125;</div><div class="line">        res = <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</div><div class="line">        <span class="comment">// Unconditionally log this, since this is generally unrecoverable.</span></div><div class="line">        RuntimeException re = <span class="keyword">new</span> RuntimeException(<span class="string">"Out of memory"</span>, e);</div><div class="line">        reply.setDataPosition(<span class="number">0</span>);</div><div class="line">        reply.writeException(re);</div><div class="line">        res = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    checkParcel(<span class="keyword">this</span>, code, reply, <span class="string">"Unreasonably large binder reply buffer"</span>);</div><div class="line">    reply.recycle();</div><div class="line">    data.recycle();</div><div class="line"></div><div class="line">    <span class="comment">// Just in case -- we are done with the IPC, so there should be no more strict</span></div><div class="line">    <span class="comment">// mode violations that have gathered for this thread.  Either they have been</span></div><div class="line">    <span class="comment">// parceled and are now in transport off to the caller, or we are returning back</span></div><div class="line">    <span class="comment">// to the main transaction loop to wait for another incoming transaction.  Either</span></div><div class="line">    <span class="comment">// way, strict mode begone!</span></div><div class="line">    StrictMode.clearGatheredViolations();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章基本是通过翻译 Binder 的官方原文来了解它的使用机制，Binder 的使用还是非常简单和高效的，在使用的同时也不需要担心会有丢失的情况。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/18/Android-浅析-Binder-机制-基础-一/" data-id="civ9405rc0000akqtiqj2fn55" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binder/">Binder</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-Broadcast-三-发送原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/18/Android-浅析-Broadcast-三-发送原理/" class="article-date">
  <time datetime="2016-09-18T07:59:58.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/Android-浅析-Broadcast-三-发送原理/">Android 浅析 Broadcast (三) 发送原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>Broadcast的发送是以AMS为中心，通过AMS的分发将消息分发到对应的接收器中。并且这个过程是通过IPC Binder 来完成的。</p>
</blockquote>
<p>发送流程图<br><img src="http://ww3.sinaimg.cn/large/7669bef3gw1eykjfyq6xej21kw0izwh4.jpg" alt="发送流程"></p>
<h2 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h2><h3 id="Step-1-ContextWrapper-sendBroadcast"><a href="#Step-1-ContextWrapper-sendBroadcast" class="headerlink" title="Step 1.ContextWrapper.sendBroadcast()"></a>Step 1.ContextWrapper.sendBroadcast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"..."</span>);</div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure>
<p>这是第一步，发送广播的操作非常简单，生成一个Intent，然后调用sendBroadcast发送就可以了。ContextWrapper的调用其实是一个代理类，实际调用是在ContextImpl。</p>
<h3 id="Step-2-ContextImpl-sendBroadcast"><a href="#Step-2-ContextImpl-sendBroadcast" class="headerlink" title="Step 2.ContextImpl.sendBroadcast()"></a>Step 2.ContextImpl.sendBroadcast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">intent.prepareToLeaveProcess();</div><div class="line">ActivityManagerNative.getDefault().broadcastIntent(...);</div></pre></td></tr></table></figure>
<p>在ContextImpl才是发送广播的起点，首先Intent会调用prepareToLeaveProcess()准备离开现有进程，然后调用AMS的broadcastIntent()开始发送过程。</p>
<h3 id="Step-3-ActivityManagerNative-broadcastIntent"><a href="#Step-3-ActivityManagerNative-broadcastIntent" class="headerlink" title="Step 3.ActivityManagerNative.broadcastIntent()"></a>Step 3.ActivityManagerNative.broadcastIntent()</h3><p>这个类就是一个代理，这个函数的职责很简单，将传过来的参数打包到Parcel，然后通过<strong>Binder</strong>将数据传到AMS里。</p>
<h3 id="Step-4-ActivityManagerService-broadcastIntent"><a href="#Step-4-ActivityManagerService-broadcastIntent" class="headerlink" title="Step 4.ActivityManagerService.broadcastIntent()"></a>Step 4.ActivityManagerService.broadcastIntent()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> res = broadcastIntentLocked(...)</div></pre></td></tr></table></figure>
<p>此函数就是解析一下传进来的数据，然后调用AMS的broadcastIntentLocked进行下一步。</p>
<h3 id="Step-5-ActivityManagerService-broadcastIntentLocked"><a href="#Step-5-ActivityManagerService-broadcastIntentLocked" class="headerlink" title="Step 5.ActivityManagerService.broadcastIntentLocked()"></a>Step 5.ActivityManagerService.broadcastIntentLocked()</h3><p>这个函数比较长，我们一段一段来看。</p>
<h4 id="Part-1："><a href="#Part-1：" class="headerlink" title="Part 1："></a>Part 1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">intent = <span class="keyword">new</span> Intent(intent);</div><div class="line">...</div><div class="line"><span class="comment">// Figure out who all will receive this broadcast.</span></div><div class="line">List receivers = <span class="keyword">null</span>;</div><div class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (...) &#123;</div><div class="line">    registeredReceivers = mReceiverResolver.queryIntent(intent,...);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    registeredReceivers = mReceiverResolver.queryIntent(intent,...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一段是根据Intent的值找出相应接受的广播接收器。因为AMS会把注册的广播接收器保存到mReceiverResolver变量里。</p>
<h4 id="Part-2："><a href="#Part-2：" class="headerlink" title="Part 2："></a>Part 2：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> replacePending =  (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>这一段就是判断是否要替换之前的intent。</p>
<h4 id="Part-3："><a href="#Part-3：" class="headerlink" title="Part 3："></a>Part 3：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</div><div class="line">BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(...);</div><div class="line">queue.enqueueParallelBroadcastLocked(r);</div><div class="line">queue.scheduleBroadcastsLocked();</div></pre></td></tr></table></figure>
<p>这里首先会通过broadcastQueueForIntent()从AMS的全局变量mFgBroadcastQueue或mBgBroadcastQueue中获取一个队列，里面保存着所有Broadcast对象。然后通过获取的参数新创建一块BroadcastRecord块，将它添加到队列里面去。接下来我们看scheduleBroadcastsLocked()的过程。</p>
<h3 id="Step-6-BroadcastQueue-scheduleBroadcastsLocked"><a href="#Step-6-BroadcastQueue-scheduleBroadcastsLocked" class="headerlink" title="Step 6.BroadcastQueue.scheduleBroadcastsLocked()"></a>Step 6.BroadcastQueue.scheduleBroadcastsLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mBroadcastsScheduled) &#123;<span class="keyword">return</span>;&#125;</div><div class="line">mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</div><div class="line">mBroadcastsScheduled = <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
<p>这里的mBroadcastsScheduled表示AMS当前是不是正在处理其它广播，如果是的话，这里就先不处理直接返回了，保证所有广播串行处理。<br>因为是通过消息的方式来发送，所以广播的发送和处理是异步的。成员变量mHandler是一个AMS内部的BroadcastQueue定义的Handler类变量，把一个空的类型为BROADCAST_INTENT_MSG的消息放到队列里。</p>
<h3 id="Step-7-BroadcastQueue-handleMessage"><a href="#Step-7-BroadcastQueue-handleMessage" class="headerlink" title="Step 7.BroadcastQueue.handleMessage()"></a>Step 7.BroadcastQueue.handleMessage()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BROADCAST_INTENT_MSG：</div><div class="line">    processNextBroadcast(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<p>很简单，又是通过processNextBroadcast()来处理下一条广播。</p>
<h3 id="Step-8-BroadcastQueue-processNextBroadcast"><a href="#Step-8-BroadcastQueue-processNextBroadcast" class="headerlink" title="Step 8.BroadcastQueue.processNextBroadcast()"></a>Step 8.BroadcastQueue.processNextBroadcast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mBroadcastsScheduled = <span class="keyword">false</span>;</div><div class="line">...</div><div class="line"><span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">    r = mParallelBroadcasts.remove(<span class="number">0</span>);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = r.receivers.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">        Object target = r.receivers.get(i);</div><div class="line">        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是分发的核心了，首先将mBroadcastsScheduled设为false是让下一条消息能发送，接着循环mParallelBroadcasts的size将里面的广播记录块取出来，因为里面包含了目标target，通过deliverToRegisteredReceiverLocked将它发送给订阅了的接收器。</p>
<h3 id="Step-9-BroadcastQueue-deliverToRegisteredReceiverLocked"><a href="#Step-9-BroadcastQueue-deliverToRegisteredReceiverLocked" class="headerlink" title="Step 9.BroadcastQueue.deliverToRegisteredReceiverLocked()"></a>Step 9.BroadcastQueue.deliverToRegisteredReceiverLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (filter.requiredPermission != <span class="keyword">null</span>) &#123;</div><div class="line">    ...</div><div class="line">    skip = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="keyword">if</span> (!skip) &#123;</div><div class="line">    performReceiveLocked(...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一段做了很多个判断，都是在检查广播发送和接受的权限判断，如果不通过这直接跳过。在通过判断后再调用performReceiveLocked执行发送操作。</p>
<h3 id="Step-10-BroadcastQueue-performReceiveLocked"><a href="#Step-10-BroadcastQueue-performReceiveLocked" class="headerlink" title="Step 10.BroadcastQueue.performReceiveLocked()"></a>Step 10.BroadcastQueue.performReceiveLocked()</h3><p>首先来看下这个函数的参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</div></pre></td></tr></table></figure></p>
<p>这里首先判断通过注册进来的广播是什么，因为例子中是通过activity注册的，这里的app参数就是代表activity的进程记录块，receiver这是注册时传给AMS的Binder对象。<br>在调用后会通过：app.thread.scheduleRegisteredReceiver()函数把广播分发给activity。</p>
<h3 id="Step-11-ApplicationThreadNative-scheduleRegisteredReceiver"><a href="#Step-11-ApplicationThreadNative-scheduleRegisteredReceiver" class="headerlink" title="Step 11.ApplicationThreadNative.scheduleRegisteredReceiver()"></a>Step 11.ApplicationThreadNative.scheduleRegisteredReceiver()</h3><p>这里也很简单，做一个打包通过binder分发而已。</p>
<h3 id="Step-12-ApplicationThread-scheduleRegisteredReceiver"><a href="#Step-12-ApplicationThread-scheduleRegisteredReceiver" class="headerlink" title="Step 12.ApplicationThread.scheduleRegisteredReceiver()"></a>Step 12.ApplicationThread.scheduleRegisteredReceiver()</h3><p>传进来的第一个参数是<strong>IIntentReceiver receiver</strong>，其实际类型是定义在LoadedApk类的内部类ReceiverDispatcher里面的一个内部类InnerReceiver，调用performReceive函数来执行。</p>
<h3 id="Step-13-LoadedApk-ReceiverDispatcher-InnerReceiver-performReceive"><a href="#Step-13-LoadedApk-ReceiverDispatcher-InnerReceiver-performReceive" class="headerlink" title="Step 13.LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive()"></a>Step 13.LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LoadedApk.ReceiverDispatcher rd = mDispatcher.get();</div><div class="line">rd.performReceive();</div></pre></td></tr></table></figure>
<p>这里又是一个转折，调用LoadedApk.ReceiverDispatcher类的performReceive()来执行。</p>
<h3 id="Step-14-LoadedApk-ReceiverDispatcher-performReceive"><a href="#Step-14-LoadedApk-ReceiverDispatcher-performReceive" class="headerlink" title="Step 14.LoadedApk.ReceiverDispatcher.performReceive()"></a>Step 14.LoadedApk.ReceiverDispatcher.performReceive()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Handler mActivityThread;</div><div class="line">...</div><div class="line">Args args = <span class="keyword">new</span> Args()</div><div class="line"><span class="keyword">if</span> (!mActivityThread.post(args)) &#123;&#125;</div></pre></td></tr></table></figure>
<p>在ReceiverDispatcher类里mActivityThread的类型是一个handler，它是前面MainActivity注册广播接收器时，从ActivityThread取得的。这里ReceiverDispatcher借助这个Handler，把这个广播以消息的形式放到MainActivity所在的这个ActivityThread的消息队列中去。<br>而Args是ReceiverDispatcher的一个内部类，继承自Runnable类。</p>
<h3 id="Step-15-Hanlder-post"><a href="#Step-15-Hanlder-post" class="headerlink" title="Step 15.Hanlder.post"></a>Step 15.Hanlder.post</h3><p>post的作用就是把消息放在消息队列中，然后就返回，这个消息最终会在传进来的Runnable类型的参数的run成员函数中进行处理。</p>
<h3 id="Step-16-LoadedApk-ReceiverDispatcher-Args-run"><a href="#Step-16-LoadedApk-ReceiverDispatcher-Args-run" class="headerlink" title="Step 16.LoadedApk.ReceiverDispatcher.Args.run"></a>Step 16.LoadedApk.ReceiverDispatcher.Args.run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</div><div class="line"><span class="keyword">final</span> Intent intent = mCurIntent;</div><div class="line">...</div><div class="line">ClassLoader cl =  mReceiver.getClass().getClassLoader();</div><div class="line">intent.setExtrasClassLoader(cl);</div><div class="line">setExtrasClassLoader(cl);</div><div class="line">receiver.setPendingResult(<span class="keyword">this</span>);</div><div class="line">receiver.onReceive(mContext, intent);</div></pre></td></tr></table></figure>
<p>mReceiver是ReceiverDispatcher类的成员变量,它就是MainActivity注册广播接收器时创建的BroadcastReceiver实例。<br>在这里就能够通过receiver将广播分发到处理的地方了。</p>
<h3 id="Step-17-BroadcastReceiver-onReceive"><a href="#Step-17-BroadcastReceiver-onReceive" class="headerlink" title="Step 17.BroadcastReceiver.onReceive"></a>Step 17.BroadcastReceiver.onReceive</h3><p>最后就是定义在自己类里的onReceive被调用，整个过程到此结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们将整个过程来总结一下：</p>
<ol>
<li>第一阶段：<br>Step 1 ～ Step 7:通过自己的sendBroadcast把一个广播通过Binder进程间通信机制发送给AMS，AMS根据这个广播的Action类型找到相应的广播接收器，然后把这个广播放进自己的消息队列中去。</li>
<li>第二阶段：<br>Step 8 ～ Step 15:AMS在消息循环中处理这个广播，并通过Binder进程间通信机制把这个广播分发给注册的广播接收分发器ReceiverDispatcher，ReceiverDispatcher把这个广播放进MainActivity所在的线程的消息队列中去。</li>
<li>第三阶段：<br>Step 16 ～ Step 17:<br>ReceiverDispatcher的内部类Args在MainActivity所在的线程消息循环中处理这个广播，最终是将这个广播分发给所注册的BroadcastReceiver实例的onReceive函数进行处理。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/18/Android-浅析-Broadcast-三-发送原理/" data-id="civ9405rs000aakqtnrikcc81" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Broadcast/">Broadcast</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-Broadcast-二-注册原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/18/Android-浅析-Broadcast-二-注册原理/" class="article-date">
  <time datetime="2016-09-18T06:39:10.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/Android-浅析-Broadcast-二-注册原理/">Android 浅析 Broadcast (二) 注册原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>本章通过跟踪registerReceiver(BroadcastReceiver receiver, IntentFilter filter)函数一路深入广播是如何被注册的。</p>
</blockquote>
<h2 id="动态注册过程"><a href="#动态注册过程" class="headerlink" title="动态注册过程"></a>动态注册过程</h2><h3 id="Step-1-ContextWrapper-registerReceiver"><a href="#Step-1-ContextWrapper-registerReceiver" class="headerlink" title="Step 1.ContextWrapper.registerReceiver()"></a>Step 1.ContextWrapper.registerReceiver()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">Context mBase;</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></div><div class="line">    BroadcastReceiver receiver, IntentFilter filter) &#123;</div><div class="line">    <span class="keyword">return</span> mBase.registerReceiver(receiver, filter);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Step-2-ContextImpl-registerReceiver"><a href="#Step-2-ContextImpl-registerReceiver" class="headerlink" title="Step 2.ContextImpl.registerReceiver()"></a>Step 2.ContextImpl.registerReceiver()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> LoadedApk mPackageInfo;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(...)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> registerReceiver(receiver, filter, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(...)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> registerReceiverInternal(...);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(...)</span> </span>&#123;</div><div class="line">    IIntentReceiver rd = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</div><div class="line">                scheduler = mMainThread.getHandler();</div><div class="line">            &#125;</div><div class="line">            rd = mPackageInfo.getReceiverDispatcher(</div><div class="line">                receiver, context, scheduler,</div><div class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</div><div class="line">                scheduler = mMainThread.getHandler();</div><div class="line">            &#125;</div><div class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</div><div class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(</div><div class="line">            mMainThread.getApplicationThread(), mBasePackageName, </div><div class="line">            rd, filter, broadcastPermission, userId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过几层的封装，最终会到ContextImpl.registerReceiverInternal这函数里，mPackageInfo变量是一个LoadedApk对象，LoadedApk是用来负责处理广播的接收。这里面首先会调用mMainThread.getHandler()来获取一个handler，先来看这个函数的过程再往下走。</p>
<h3 id="Step-3-ActivityThread-getHandler"><a href="#Step-3-ActivityThread-getHandler" class="headerlink" title="Step 3.ActivityThread.getHandler()"></a>Step 3.ActivityThread.getHandler()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">final</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> mH;&#125;</div><div class="line">...</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到最终是传回一个handler的对象，有这个对象就可以分发ActivityManagerService发送过来的广播消息给这个进程处理了。</p>
<p>接下来这个registerReceiverInternal函数通过LoadedApk.ReceiverDispatcher()获取一个IIntentReceiver接口对象rd，这是一个Binder对象。</p>
<h3 id="Step-4-LoadedApk-getIIntentReceiver"><a href="#Step-4-LoadedApk-getIIntentReceiver" class="headerlink" title="Step 4.LoadedApk.getIIntentReceiver()"></a>Step 4.LoadedApk.getIIntentReceiver()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> IIntentReceiver.Stub mIIntentReceiver;</div><div class="line">...</div><div class="line">ReceiverDispatcher(...) &#123;</div><div class="line">    mIIntentReceiver = <span class="keyword">new</span> InnerReceiver(<span class="keyword">this</span>, !registered);</div><div class="line">    mReceiver = receiver;</div><div class="line">    mContext = context;</div><div class="line">    mActivityThread = activityThread;</div><div class="line">    mInstrumentation = instrumentation;</div><div class="line">    mRegistered = registered;</div><div class="line">    mLocation = <span class="keyword">new</span> IntentReceiverLeaked(<span class="keyword">null</span>);</div><div class="line">    mLocation.fillInStackTrace();</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="function">IIntentReceiver <span class="title">getIIntentReceiver</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mIIntentReceiver;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数里，创建了一个新的Receiver接口，并且将一个Activity和BroadcastReceiver绑定到LoadedApk，这样就可以在LoadedApk里查看是否存在相应的广播接收和发布器了。<br>在这里创建了一个InnerReceiver对象，这是一个Binder对象，实现了IIntentReceiver接口。最后通过getIIntentReceiver()返回给外部。</p>
<h3 id="Step-5-ActivityManagerNative-registerReceiver"><a href="#Step-5-ActivityManagerNative-registerReceiver" class="headerlink" title="Step 5.ActivityManagerNative.registerReceiver()"></a>Step 5.ActivityManagerNative.registerReceiver()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(...)</span></span></div><div class="line">&#123;</div><div class="line">    Parcel data = Parcel.obtain();</div><div class="line">    Parcel reply = Parcel.obtain();</div><div class="line">    ...</div><div class="line">    mRemote.transact(REGISTER_RECEIVER_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">    ...</div><div class="line">    Intent intent = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> haveIntent = reply.readInt();</div><div class="line">    <span class="keyword">if</span> (haveIntent != <span class="number">0</span>) &#123;</div><div class="line">        intent = Intent.CREATOR.createFromParcel(reply);</div><div class="line">    &#125;</div><div class="line">    reply.recycle();</div><div class="line">    data.recycle();</div><div class="line">    <span class="keyword">return</span> intent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数最主要就是通过Binder驱动进入到ActivityManagerService中调用AMS的registerReceiver函数。</p>
<h3 id="Step-6-ActivityManagerService-registerReceiver"><a href="#Step-6-ActivityManagerService-registerReceiver" class="headerlink" title="Step 6.ActivityManagerService.registerReceiver()"></a>Step 6.ActivityManagerService.registerReceiver()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage,</span></span></div><div class="line">        IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId) &#123;</div><div class="line">    ArrayList&lt;Intent&gt; stickyIntents = <span class="keyword">null</span>;</div><div class="line">    ProcessRecord callerApp = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> callingUid;</div><div class="line">    <span class="keyword">int</span> callingPid;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数比较长，我们分成几个模块来解析。</p>
<h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</div><div class="line">    callerApp = getRecordForAppLocked(caller);</div><div class="line">    ...</div><div class="line">&#125; </div><div class="line">...</div></pre></td></tr></table></figure>
<p>这里首先是获得调用registerReceiver函数的应用程序进程记录块，在这个Broadcast的进程记录块里就有MainActivity的启动代码。</p>
<h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (actions.hasNext()) &#123;</div><div class="line">    String action = actions.next();</div><div class="line">    ..</div><div class="line">    ArrayList&lt;Intent&gt; intents = stickies.get(action);</div><div class="line">    <span class="keyword">if</span> (intents != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (stickyIntents == <span class="keyword">null</span>) &#123;</div><div class="line">            stickyIntents = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</div><div class="line">        &#125;</div><div class="line">        stickyIntents.addAll(intents);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">...</div><div class="line">ArrayList&lt;Intent&gt; allSticky = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (stickyIntents != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">final</span> ContentResolver resolver = mContext.getContentResolver();</div><div class="line">    ...</div><div class="line">    Intent intent = stickyIntents.get(i);</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (allSticky == <span class="keyword">null</span>) &#123;</div><div class="line">        allSticky = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</div><div class="line">    &#125;</div><div class="line">    allSticky.add(intent);</div><div class="line">&#125;</div><div class="line">Intent sticky = allSticky != <span class="keyword">null</span> ? allSticky.get(<span class="number">0</span>) : <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>接下来是处理一个粘性的广播，将intents添加到stickyIntents里。代码虽多但功能简单。</p>
<h4 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</div><div class="line"><span class="keyword">if</span> (rl == <span class="keyword">null</span>) &#123;</div><div class="line">    rl = <span class="keyword">new</span> ReceiverList(<span class="keyword">this</span>, callerApp, callingPid, callingUid,</div><div class="line">            userId, receiver);</div><div class="line">    <span class="keyword">if</span> (rl.app != <span class="keyword">null</span>) &#123;</div><div class="line">        rl.app.receivers.add(rl);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        receiver.asBinder().linkToDeath(rl, <span class="number">0</span>);</div><div class="line">        rl.linkedToDeath = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    mRegisteredReceivers.put(receiver.asBinder(), rl);</div><div class="line">&#125;</div><div class="line">BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</div><div class="line">        permission, callingUid, userId);</div><div class="line">rl.add(bf);</div><div class="line">mReceiverResolver.addFilter(bf);</div><div class="line">...</div><div class="line"><span class="keyword">return</span> sticky;</div></pre></td></tr></table></figure>
<p>这里就是把广播接收器receiver保存一个ReceiverList列表中，这个列表的宿主进程是rl.app，这里就是MainActivity所在的进程了，在ActivityManagerService中，用一个进程记录块来表示这个应用程序进程，它里面有一个列表receivers，专门用来保存这个进程注册的广播接收器。接着，又把这个ReceiverList列表以receiver为Key值保存在ActivityManagerService的成员变量mRegisteredReceivers中，这些都是为了方便在收到广播时，快速找到对应的广播接收器的。<br>最后把广播接收器receiver和filter关联起来并保存到AMS的成员mReceiverResolver里。</p>
<h2 id="静态注册过程"><a href="#静态注册过程" class="headerlink" title="静态注册过程"></a>静态注册过程</h2><h3 id="Step-1-AndroidManifest"><a href="#Step-1-AndroidManifest" class="headerlink" title="Step 1.AndroidManifest"></a>Step 1.AndroidManifest</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;receiver android:name=".MyBroadcastReceiver"&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;action android:name="com.unknow.jason.broadcasttest.MY_BROADCAST"/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<p>在manifest添加receiver标签并且配上intentfilter。</p>
<h3 id="Step-2-PackageManagerService-scanDirLI"><a href="#Step-2-PackageManagerService-scanDirLI" class="headerlink" title="Step 2.PackageManagerService.scanDirLI()"></a>Step 2.PackageManagerService.scanDirLI()</h3><p>PMS管理类里面的scanDirLI()函数是安装流程的开吃，无论是开机安装APK、手动还是自动等安装方式，都会走到这个函数里。<br>scanDirLI()函数主要做的是对于后缀为APK的文件进行解析和安装。这里我们只看解析的函数。<br>scanDirLI()函数里解析的功能传递给<strong>scanPackageLI()</strong>函数执行。</p>
<h3 id="Step-3-PackageManagerService-scanPackageLI"><a href="#Step-3-PackageManagerService-scanPackageLI" class="headerlink" title="Step 3.PackageManagerService.scanPackageLI()"></a>Step 3.PackageManagerService.scanPackageLI()</h3><p>scanPackageLI()函数对APK文件的解析过程是由PackageParser实例执行。该实例执行完解析后会保存在PMS中，其中就包括Receiver信息。<br>scanPackageLI()函数说调用的PackageParser实例函数是<strong>parsePackage()</strong>。</p>
<h3 id="Step-4-PackageParser-parsePackage"><a href="#Step-4-PackageParser-parsePackage" class="headerlink" title="Step 4.PackageParser.parsePackage()"></a>Step 4.PackageParser.parsePackage()</h3><p>每一个Apk文件都是一个归档文件，里面包含了Android应用程序的配置文件AndroidManifest.xml，这里主要就是要对这个配置文件进行解析，解析完成后就会从Apk归档文件中得到这个配置文件，然后调用另外一个parsePackage()。<br>在第二个parsePackage()函数里就会对我们AndroidManifest.xml里的标签进行解析了。<br>接下来对Receiver的解析存在在”application”里，对”application”的解析是调用parseApplication函数。</p>
<h3 id="Step-5-PackageParser-parseApplication"><a href="#Step-5-PackageParser-parseApplication" class="headerlink" title="Step 5.PackageParser.parseApplication()"></a>Step 5.PackageParser.parseApplication()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (tagName.equals(<span class="string">"activity"</span>)) &#123;</div><div class="line">    ...</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"receiver"</span>)) &#123;</div><div class="line">    Activity a = parseActivity(...);</div><div class="line">    ...</div><div class="line">    owner.receivers.add(a);</div><div class="line">&#125; ...</div></pre></td></tr></table></figure>
<p>这里上一点代码。我们看到这里有两个步骤。<br>第一：从parseActivity()函数里取得标签的内容。<br>第二：将它们保存到receivers里面。<br>我们首先来看parseActivity()函数是如何解析的。</p>
<h3 id="Step-6-PackageParser-parseActivity"><a href="#Step-6-PackageParser-parseActivity" class="headerlink" title="Step 6.PackageParser.parseActivity()"></a>Step 6.PackageParser.parseActivity()</h3><p>parseActivity()这个函数，“<receiver>”和“<activity>”两个标签的解析都用同一个函数。在解析完这些数据后会返回一个Activity对象，里面就包含了所有标签数据。<br>当解析完成后会一路沿着传递路线返回，一直返回到Step3。将数据保存在PackageParser.Package对象里。<br>接下来会调用另一个<strong>scanPackageLI()</strong>函数。</activity></receiver></p>
<h3 id="Step-7-PackageManagerService-scanPackageLI"><a href="#Step-7-PackageManagerService-scanPackageLI" class="headerlink" title="Step 7.PackageManagerService.scanPackageLI()"></a>Step 7.PackageManagerService.scanPackageLI()</h3><p>这函数其实就是封装了一层，实际的操作函数是scanPackageDirtyLI()。</p>
<h3 id="Step-8-PackageManagerService-scanPackageDirtyLI"><a href="#Step-8-PackageManagerService-scanPackageDirtyLI" class="headerlink" title="Step 8.PackageManagerService.scanPackageDirtyLI()"></a>Step 8.PackageManagerService.scanPackageDirtyLI()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">N = pkg.receivers.size();</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">    PackageParser.Activity a = pkg.receivers.get(i);</div><div class="line">    mReceivers.addActivity(a, <span class="string">"receiver"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们可以看到这里，最后将receiver从package里面获取出来保存到PMS里面的一个全局变量mReceivers里，这样以后想查询就可以直接从PMS这里获取了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从两个注册的过程来看，我们可以知道receiver无论是从动态注册还是静态注册，最后都是AMS负责将其交互给用户，分别只在于一个字节保存到AMS另一个则要先保存到PMS然后AMS去获取。<br>过程都不复杂，重点是不要被太多枝叶给分散注意。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/18/Android-浅析-Broadcast-二-注册原理/" data-id="civ9405rs0009akqtqlrbwhmg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Broadcast/">Broadcast</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-Broadcast-一-使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/18/Android-浅析-Broadcast-一-使用/" class="article-date">
  <time datetime="2016-09-18T04:07:38.000Z" itemprop="datePublished">2016-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/Android-浅析-Broadcast-一-使用/">Android 浅析 Broadcast (一) 使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>广播(Broadcast)是在组件之间传播数据（Intent）的一种机制。通过Broadcast发送者和接收者，并且不需要知道对方存在。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Step-1-创建接收类"><a href="#Step-1-创建接收类" class="headerlink" title="Step 1. 创建接收类"></a>Step 1. 创建接收类</h3><p>创建一个接收类继承BroadcastReceiver类，并覆写onReceive()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Step-2-注册广播接收器"><a href="#Step-2-注册广播接收器" class="headerlink" title="Step 2. 注册广播接收器"></a>Step 2. 注册广播接收器</h3><h4 id="1-静态注册"><a href="#1-静态注册" class="headerlink" title="1.静态注册"></a>1.静态注册</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;application &gt;</div><div class="line">    &lt;receiver android:name=".MyBroadcastReceiver"&gt;</div><div class="line">        &lt;intent-filter&gt;</div><div class="line">            &lt;action android:name="com.unknow.jason.broadcasttest.MY_BROADCAST"/&gt;</div><div class="line">        &lt;/intent-filter&gt;</div><div class="line">    &lt;/receiver&gt;</div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure>
<h4 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2.动态注册"></a>2.动态注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">intentFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line">intentFilter.addAction(<span class="string">"com.unknow.jason.broadcasttest.MY_BROADCAST"</span>);</div><div class="line"></div><div class="line">myBroadcastReceiver = <span class="keyword">new</span> MyBroadcastReceiver();</div><div class="line">registerReceiver(myBroadcastReceiver, intentFilter);</div><div class="line"></div><div class="line">unregisterReceiver(myBroadcastReceiver);</div></pre></td></tr></table></figure>
<h3 id="Step-3-发送广播"><a href="#Step-3-发送广播" class="headerlink" title="Step 3. 发送广播"></a>Step 3. 发送广播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.unknow.jason.broadcasttest.MY_BROADCAST"</span>);</div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure>
<h2 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h2><h3 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><blockquote>
<p>Base class for code that will receive intents sent by sendBroadcast().<br>翻译：基础类可以接受来自sendBroadcast()发出的intents。</p>
</blockquote>
<p><strong>如果你不需要在应用程序发送广播，考虑使用localbroadcastmanager类</strong>代替接下来描述的一般工具。这会给你一个更有效的实现（无需跨进程通信），并允许您避免考虑与其他应用程序能够接收或发送广播任何安全问题。</p>
<p>您可以动态地注册这个类用Context.registerReceiver()方法或静态的实例，通过发布在AndroidManifest.xml中的&lt;接收&gt;标记的实现。</p>
<p>注意：如果注册一个接收器在Activity.onResume()函数，你需要反注册在Activity.onPause(). 这将减少不必要的系统开销。不要在Activity.onSaveInstanceState()注册。</p>
<p>有两个主要的类的广播可以用来接收。</p>
<ol>
<li>普通广播：(使用 Context.sendBroadcast发出)是完全异步的。所有接收者都运行在一个未定义的顺序里，有时甚至同时接收。这很高效，但也意味着不能使用结束或暂停API。</li>
<li>有序广播：(使用 Context.sendOrderedBroadcast发出)同一时间只传递一个接收器。每个接收器依次执行，它可以传送结果到下一个接收器，当然也可以暂停传送。这个顺序在android:priority属性里通过 intent-filter定义，如果定义同样的优先级则是随机顺序。</li>
</ol>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>有这么几点建议：</p>
<ol>
<li>这个Intent的命名空间是全局的。</li>
<li>当你使用registerReceiver()，任何应用程序可以向该注册的接收者发送广播。你可以控制谁可以通过定义的权限发送广播到它。</li>
<li>当你在应用程序的清单中发布一个接收器并为它指定一个IntentFilter，任何其他应用程序都可以发送到它的广播，不管你指定的筛选器。为了防止别人发送到它，使他们无法使用安卓：android:exported=”false”。</li>
<li>当你使用sendBroadcast(Intent)或者相关方法，一般任何其他应用程序都可以接收这些广播。你可以通过定义的权限控制谁可以接收这些广播。另外，从ice_cream_sandwich，你也可以安全限制广播到单个应用程序利用Intent.setpackage。</li>
</ol>
<h4 id="接收者的生命周期"><a href="#接收者的生命周期" class="headerlink" title="接收者的生命周期"></a>接收者的生命周期</h4><p>一个广播接收者有一个回调方法：void onReceive()。当一个广播消息到达接收者时，Android调用它的onReceive()方法并传递给它包含消息的Intent对象。广播接收者被认为仅当它执行这个方法时是活跃的。当onReceive()返回后，它是不活跃的。有一个活跃的广播接收者的进程是受保护的，不会被杀死。但是系统可以在任何时候杀死仅有不活跃组件的进程，当占用的内存别的进程需要时。<br>特别是，你可能不会显示一个对话框或绑定到一个服务在一个BroadcastReceiver中。对于前者，你应该使用NotificationManager API。对于后者，你可以使用上下文：startservice()将命令发送到服务。</p>
<h4 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h4><p>一个进程，目前正在执行一个BroadcastReceiver(即目前在运行onReceive代码(Context,Intent)函数)被认为是一个前台进程将保持运行的系统除了在极端的内存压力下。<br>这意味着<strong>如果想保持进程长时间运行可以经常利用一个服务去调用BroadcastReceiver来保持进程不被删除</strong></p>
<h4 id="onReceive"><a href="#onReceive" class="headerlink" title="onReceive()"></a>onReceive()</h4><p>这个方法是当BroadcastReceiver收到一个Intent broadcast消息是被调用。该方法是在其进程的主线程调用的，除非明确地要求运行在不同的线程利用registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)这个函数。不允许在主线程做耗时的任务，因此也不要onreceive()推出弹出对话框。<br>如果这个BroadcastReceiver通过<receiver>标签发送，当这个函数返回后这个对象将不在存在。这意味着你不应该进行任何操作在返回结果后特别是异步，对正在互动的服务，应该用startService(Intent)代替bindService(Intent, ServiceConnection, int)。如果你希望和正在运行的服务互动，应该调用peekService(Context, Intent)。<br>被用在registerReceiver(BroadcastReceiver, IntentFilter) 和application manifests的IntentFilter不保证独有。onReceive()实现应该只对已知的action作出反应，忽略那些未知的被收到的Intent。</receiver></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/18/Android-浅析-Broadcast-一-使用/" data-id="civ9405rc0005akqta71fs9pl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Broadcast/">Broadcast</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-消息事件分发机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/14/Android-浅析-消息事件分发机制/" class="article-date">
  <time datetime="2016-09-14T08:01:57.000Z" itemprop="datePublished">2016-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/14/Android-浅析-消息事件分发机制/">Android 浅析 消息事件分发机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>事件系统分为四部分：采集信息、前期处理、WMS分配、应用程序处理。</p>
</blockquote>
<ul>
<li>采集信息：就是硬件部分收集点击的事件。</li>
<li>前期处理：对刚收集的事件进行格式处理。</li>
<li>WMS 分配：WMS 记录了当前系统所有窗口完整状态信息，所以可以判断事件投递的具体进程。</li>
<li>应用程序处理：最后派发给应用程序让我们自己来处理。</li>
</ul>
<h2 id="采集信息"><a href="#采集信息" class="headerlink" title="采集信息"></a>采集信息</h2><blockquote>
<p>采集信息基本都是硬件部分的事，无论对屏幕的触碰事件还是键盘的点击事件都是由手机硬件采集，然后保存在本地的一个事件文件里面。</p>
</blockquote>
<h2 id="前期处理"><a href="#前期处理" class="headerlink" title="前期处理"></a>前期处理</h2><blockquote>
<p>在采集完信息后要做最初的事件处理，例如分类：Home、Back、Menu等。事件类型：拖动、点击、其它等。</p>
</blockquote>
<h2 id="WMS-分配事件"><a href="#WMS-分配事件" class="headerlink" title="WMS 分配事件"></a>WMS 分配事件</h2><blockquote>
<p>Android系统中负责管理输入事件的主要是InputManagerService（IMS）。它主要的任务就是从设备中读事件数据，然后将输入事件发送到焦点窗口中去，另外还需要让系统有机会来处理一些系统按键。</p>
</blockquote>
<p>在<code>InputManagerService</code>里包含了两个非常重要的工作线程。</p>
<h3 id="InputReaderThread"><a href="#InputReaderThread" class="headerlink" title="InputReaderThread"></a>InputReaderThread</h3><blockquote>
<p>一个独立的循环线程，主要任务就是不断地轮询相关设备节点查看是否有新的事件发生。并将事件告知派发系统。</p>
</blockquote>
<h3 id="InputDispatcherThread"><a href="#InputDispatcherThread" class="headerlink" title="InputDispatcherThread"></a>InputDispatcherThread</h3><blockquote>
<p>一个独立的线程，用以处理从事件轮询系统告知过来的事件，保证事件的正确派发和处理。</p>
</blockquote>
<p>在初始化的最初会以参数的形式将InputDispatcherThread的对象封装进InputReaderThread里，在InputReader的loopOnce循环里会不断通过Dispatcher将事件发送给Listener。</p>
<p>InputDispatcherThread 的一个核心工作就是确定事件的接收对象。</p>
<p>在WMS 和 InputDispatcher 的中间存在着一个InputMonitor对象，这个对象作为中介，工作主要分为两部分，第一：实现WindowManagerCallbacks接口，WindowManagerCallbacks包含了一些例如输入设备的配置变更，连接InputDispatcher与应用程序Socket通道，等等的接口。第二：为WMS 访问InputDispatcher提供函数实现。比如InputDispatcher中当前焦点窗口，就是WMS 通过InputMonitor来获取的。</p>
<h4 id="通知应用程序窗口"><a href="#通知应用程序窗口" class="headerlink" title="通知应用程序窗口"></a>通知应用程序窗口</h4><p>InputDispatcher与应用程序的通信不是通过Binder来实现，而是通过管道channel来实现，就是Unix Domain Socket 实现，并且是一个双向的通道。因为重点是所有的应用程序都会在WMS里有注册，所以也只有WMS 能正确派发事件。</p>
<h2 id="应用程序处理"><a href="#应用程序处理" class="headerlink" title="应用程序处理"></a>应用程序处理</h2><blockquote>
<p>在经过InputDispatcher传入事件后，就由用户的应用程序来处理最后的事件了。</p>
</blockquote>
<p>首先，我们来看下事件的分发流程。</p>
<h3 id="事件分发但一直没处理"><a href="#事件分发但一直没处理" class="headerlink" title="事件分发但一直没处理"></a>事件分发但一直没处理</h3><p><img src="http://note.youdao.com/yws/public/resource/dd04c831fb2695d3e436dec8741eeefb/79E50B91774C4B0EB5EFFFFFFEFC8E31" alt="分发流程"></p>
<h3 id="事件分发并且处理了"><a href="#事件分发并且处理了" class="headerlink" title="事件分发并且处理了"></a>事件分发并且处理了</h3><p><img src="http://note.youdao.com/yws/public/resource/dd04c831fb2695d3e436dec8741eeefb/6F960403CC794738B3FADA062CCC3DCA" alt="分发流程1"></p>
<h3 id="事件分发并且被layout消费"><a href="#事件分发并且被layout消费" class="headerlink" title="事件分发并且被layout消费"></a>事件分发并且被layout消费</h3><p><img src="http://note.youdao.com/yws/public/resource/dd04c831fb2695d3e436dec8741eeefb/DCED5D6B8BA747BFB39937C5C00E3245" alt="分发流程2"></p>
<p>通过这三个图我们就可以很清楚的看到事件的分发流程顺序，并且在处理与不处理的反馈上清晰明了。</p>
<p>重点说下，在事件被分发到View层的时候如果同时监听了<code>OnTouchListener</code>、<code>OnClickListener</code>，那么很遗憾，如果在OnTouchListener消费了这个事件，那么clicklistener是无法接收这个事件的，原因就是因为在View派发消息时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  </div><div class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> onTouchEvent(event);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>mOnTouchListener.onTouch(this, event)</code>这个函数优于<code>onTouchEvent(event)</code>前处理。如果想OnClickListener也可以处理也很简单，onTouch(…)返回false就行了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/14/Android-浅析-消息事件分发机制/" data-id="civ9405s70012akqtk2h1r5vl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-FreeLoad" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/14/FreeLoad/" class="article-date">
  <time datetime="2016-09-14T04:24:48.000Z" itemprop="datePublished">2016-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/FreeLoad/">FreeLoad</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/14/FreeLoad/">FreeLoad 下载库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Freeload 是一款下载引擎。通过它你可以很方便的添加下载任务，并且实时获取下载过程。该引擎轻巧易于维护，并且拥有很好的扩展性。在新版的引擎中添加了多线程下载单资源的支持，能够支持双线程、三线程甚至四线程同步下载单资源。使用上支持链式编程，让代码编辑更加合理。</p>
        
          <p class="article-more-link">
            <a href="/2016/09/14/FreeLoad/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/14/FreeLoad/" data-id="civ9405sn001aakqtmeml55gl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FreeLoad/">FreeLoad</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-Ashmem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/22/Android-浅析-Ashmem/" class="article-date">
  <time datetime="2015-11-22T08:03:33.000Z" itemprop="datePublished">2015-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/22/Android-浅析-Ashmem/">Android 浅析 Ashmem</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><blockquote>
<p>匿名共享内存子系统Ashmem（Anonymous Shared Memory），它以驱动程序的形式实现在内核空间中。它有两个特点，一是能够辅助内存管理系统来有效地管理不再使用的内存块，二是它通过Binder进程间通信机制来实现进程间的内存共享。<br>Android的Ashmem建立在Linux内核实现的共享内存的基础上封装了一层。</p>
</blockquote>
<h2 id="Java-接口分析"><a href="#Java-接口分析" class="headerlink" title="Java 接口分析"></a>Java 接口分析</h2><blockquote>
<p>Android应用程序框架层，提供了一个MemoryFile接口来封装了匿名共享内存文件的创建和使用</p>
</blockquote>
<p>地址：frameworks/base/core/java/android/os/MemoryFile.java</p>
<p>首先通过底层接口来大致了解下ashmem的操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> file_operations ashmem_fops = &#123;  </div><div class="line">    .owner = THIS_MODULE,  </div><div class="line">    .open = ashmem_open,  </div><div class="line">    .release = ashmem_release,  </div><div class="line">    .mmap = ashmem_mmap,  </div><div class="line">    .unlocked_ioctl = ashmem_ioctl,  </div><div class="line">    .compat_ioctl = ashmem_ioctl,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>它提供了open、mmap、release和ioctl四种操作，因为是通过内存映射地址来进行读写的操作，所以没有提供read和write操作。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemoryFile</span><span class="params">(String name, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    mLength = length;</div><div class="line">    <span class="keyword">if</span> (length &gt;= <span class="number">0</span>) &#123;</div><div class="line">        mFD = native_open(name, length);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Invalid length: "</span> + length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</div><div class="line">        mAddress = native_mmap(mFD, length, PROT_READ | PROT_WRITE);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mAddress = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造函数具体的工作就是通过JNI调用C++的内核来进行初始化的工作，具体就是实现了open和mmap的构造。</p>
<ul>
<li>native_open：主要执行的操作是调用open打开设备文件/dev/ashmem，在Ashmem驱动程序中创建了一个ashmem_area结构，表示一块新的共享内存，接着调用了两次ioctl文件操作分别来设置这块新建的匿名共享内存的名字和大小。</li>
<li>native_mmap：首先获取文件描述符fd，fd是在前面open匿名设备文件/dev/ashmem获得的，之后通过mmap来执行内存映射操作了。最后的调用函数是ashmem_mmap，ashmem_mmap调用了Linux内核提供的shmem_file_setup函数来在临时文件系统tmpfs中创建一个临时文件，这个临时文件与Ashmem驱动程序创建的匿名共享内存对应。函数shmem_file_setup是Linux内核中用来创建共享内存文件的方法，而Linux内核中的共享内存机制其实是一种进程间通信（IPC）机制，它的实现相对也是比较复杂，Android系统的匿名共享内存机制正是由于直接使用了Linux内核共享内存机制，才会很小巧。最后，ashmem_mmap执行完成后，经过层层返回到JNI方法native_mmap中去，就从mmap函数的返回值中得到了这块虚拟空间的起始地址，这个起始地址最终返回到应用程序框架层的MemoryFile类的构造函数中，并且保存在成员变量mAddress中，接下来共享内存的读写操作就是对这个地址空间进行操作了。</li>
</ul>
<h3 id="读写函数"><a href="#读写函数" class="headerlink" title="读写函数"></a>读写函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">native_read</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> srcOffset, <span class="keyword">int</span> destOffset, <span class="keyword">int</span> count, <span class="keyword">boolean</span> isUnpinned)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">native_write</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> srcOffset, <span class="keyword">int</span> destOffset, <span class="keyword">int</span> count, <span class="keyword">boolean</span> isUnpinned)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Reads bytes from the memory file.</div><div class="line"> * Will throw an IOException if the file has been purged.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> srcOffset, <span class="keyword">int</span> destOffset, <span class="keyword">int</span> count)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> native_read(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Write bytes to the memory file.</div><div class="line"> * Will throw an IOException if the file has been purged.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> srcOffset, <span class="keyword">int</span> destOffset, <span class="keyword">int</span> count)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ...</div><div class="line">    native_write(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>address参数就是我们在前面执行mmap来映射匿名共享内存文件到内存中时，得到的进程虚拟地址空间的起始地址了,接着就能够直接访问了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_os_MemoryFile_read</span><span class="params">(JNIEnv* env, jobject clazz, jobject fileDescriptor, jint address, jbyteArray buffer, jint srcOffset, jint destOffset, jint count, jboolean unpinned)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);  </div><div class="line">    <span class="keyword">if</span> (unpinned &amp;&amp; ashmem_pin_region(fd, <span class="number">0</span>, <span class="number">0</span>) == ASHMEM_WAS_PURGED) &#123;  </div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);  </div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"ashmem region was purged"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    env-&gt;SetByteArrayRegion(buffer, destOffset, count, (<span class="keyword">const</span> jbyte *)address + srcOffset);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (unpinned) &#123;  </div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> count;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_os_MemoryFile_write</span><span class="params">(JNIEnv* env, jobject clazz, jobject fileDescriptor, jint address, jbyteArray buffer, jint srcOffset, jint destOffset, jint count, jboolean unpinned)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);  </div><div class="line">    <span class="keyword">if</span> (unpinned &amp;&amp; ashmem_pin_region(fd, <span class="number">0</span>, <span class="number">0</span>) == ASHMEM_WAS_PURGED) &#123;  </div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);  </div><div class="line">        jniThrowException(env, <span class="string">"java/io/IOException"</span>, <span class="string">"ashmem region was purged"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    env-&gt;GetByteArrayRegion(buffer, srcOffset, count, (jbyte *)address + destOffset);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (unpinned) &#123;  </div><div class="line">        ashmem_unpin_region(fd, <span class="number">0</span>, <span class="number">0</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> count;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是内核具体的读写操作，我们可以看到在拿到内存首地址后对数据的访问都是直接的。</p>
<h3 id="加锁和解锁函数"><a href="#加锁和解锁函数" class="headerlink" title="加锁和解锁函数"></a>加锁和解锁函数</h3><p>Android系统的运行时库提到了执行匿名共享内存的锁定和解锁操作的两个函数ashmem_pin_region和ashmem_unpin_region。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ashmem_pin_region</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> len)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">struct</span> ashmem_pin pin = &#123; offset, len &#125;;  </div><div class="line">    <span class="keyword">return</span> ioctl(fd, ASHMEM_PIN, &amp;pin);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ashmem_unpin_region</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> len)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">struct</span> ashmem_pin pin = &#123; offset, len &#125;;  </div><div class="line">    <span class="keyword">return</span> ioctl(fd, ASHMEM_UNPIN, &amp;pin);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它们最后都是通过ioctl来进行操作，只是传入的参数各不相同。分别是ASHMEM_PIN和ASHMEM_UNPIN。</p>
<p>首先先来了解下锁的数据结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * ashmem_range - represents an interval of unpinned (evictable) pages </div><div class="line"> * Lifecycle: From unpin to pin </div><div class="line"> * Locking: Protected by `ashmem_mutex' </div><div class="line"> */  </div><div class="line"><span class="keyword">struct</span> ashmem_range &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head lru;       <span class="comment">/* entry in LRU list */</span>  </div><div class="line">    <span class="keyword">struct</span> list_head unpinned;  <span class="comment">/* entry in its area's unpinned list */</span>  </div><div class="line">    <span class="keyword">struct</span> ashmem_area *asma;   <span class="comment">/* associated area */</span>  </div><div class="line">    <span class="keyword">size_t</span> pgstart;         <span class="comment">/* starting page, inclusive */</span>  </div><div class="line">    <span class="keyword">size_t</span> pgend;           <span class="comment">/* ending page, inclusive */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> purged;        <span class="comment">/* ASHMEM_NOT or ASHMEM_WAS_PURGED */</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (cmd) &#123;  </div><div class="line"><span class="keyword">case</span> ASHMEM_PIN:  </div><div class="line">    ret = ashmem_pin(asma, pgstart, pgend); </div><div class="line">    <span class="keyword">break</span>;  </div><div class="line"><span class="keyword">case</span> ASHMEM_UNPIN:  </div><div class="line">    ret = ashmem_unpin(asma, pgstart, pgend);  </div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据当前要执行的是ASHMEM_PIN操作还是ASHMEM_UNPIN操作来分别执行ashmem_pin和ashmem_unpin来进一步处理。<strong>创建匿名共享内存时，默认所有的内存都是pinned状态的</strong>，只有用户告诉Ashmem驱动程序要unpin某一块内存时，Ashmem驱动程序才会把这块内存unpin，之后，用户可以再告诉Ashmem驱动程序要重新pin某一块之前被unpin过的内块，从而把这块内存从unpinned状态改为pinned状态，也就是说，执行ASHMEM_PIN操作时，目标对象必须是一块当前处于unpinned状态的内存块。</p>
<p>ashmem_unpin函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * ashmem_unpin - unpin the given range of pages. Returns zero on success. </div><div class="line"> * </div><div class="line"> * Caller must hold ashmem_mutex. </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ashmem_unpin</span><span class="params">(<span class="keyword">struct</span> ashmem_area *asma, <span class="keyword">size_t</span> pgstart, <span class="keyword">size_t</span> pgend)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">struct</span> ashmem_range *range, *next;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> purged = ASHMEM_NOT_PURGED;  </div><div class="line">  </div><div class="line">restart:  </div><div class="line">    list_for_each_entry_safe(range, next, &amp;asma-&gt;unpinned_list, unpinned) &#123;  </div><div class="line">        <span class="comment">/* short circuit: this is our insertion point */</span>  </div><div class="line">        <span class="keyword">if</span> (range_before_page(range, pgstart))  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">        <span class="comment">/* </span></div><div class="line">         * The user can ask us to unpin pages that are already entirely </div><div class="line">         * or partially pinned. We handle those two cases here. </div><div class="line">         */  </div><div class="line">        <span class="keyword">if</span> (page_range_subsumed_by_range(range, pgstart, pgend))  </div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">        <span class="keyword">if</span> (page_range_in_range(range, pgstart, pgend)) &#123;  </div><div class="line">            pgstart = <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, range-&gt;pgstart, pgstart),  </div><div class="line">            pgend = <span class="keyword">max_t</span>(<span class="keyword">size_t</span>, range-&gt;pgend, pgend);  </div><div class="line">            purged |= range-&gt;purged;  </div><div class="line">            range_del(range);  </div><div class="line">            <span class="keyword">goto</span> restart;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> range_alloc(asma, range, purged, pgstart, pgend);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数的主体就是在遍历asma-&gt;unpinned_list列表，从中查找当前处于unpinned状态的内存块是否与将要unpin的内存块[pgstart, pgend]是否相交，如果相交，则要执行合并操作，即调整pgstart和pgend的大小，然后通过调用range_del函数删掉原来的已经被unpinned过的内存块，最后再通过range_alloc函数来重新unpinned这块调整过后的内存块[pgstart, pgend]，这里新的内存块[pgstart, pgend]已经包含了刚才所有被删掉的unpinned状态的内存。注意，这里如果找到一块相并的内存块，并且调整了pgstart和pgend的大小之后，要重新再扫描一遍asma-&gt;unpinned_list列表，因为新的内存块[pgstart, pgend]可能还会与前后的处于unpinned状态的内存块发生相交。</p>
<p>ashmem_pin函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * ashmem_pin - pin the given ashmem region, returning whether it was </div><div class="line"> * previously purged (ASHMEM_WAS_PURGED) or not (ASHMEM_NOT_PURGED). </div><div class="line"> * </div><div class="line"> * Caller must hold ashmem_mutex. </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ashmem_pin</span><span class="params">(<span class="keyword">struct</span> ashmem_area *asma, <span class="keyword">size_t</span> pgstart, <span class="keyword">size_t</span> pgend)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">struct</span> ashmem_range *range, *next;  </div><div class="line">    <span class="keyword">int</span> ret = ASHMEM_NOT_PURGED;  </div><div class="line">  </div><div class="line">    list_for_each_entry_safe(range, next, &amp;asma-&gt;unpinned_list, unpinned) &#123;  </div><div class="line">        <span class="comment">/* moved past last applicable page; we can short circuit */</span>  </div><div class="line">        <span class="keyword">if</span> (range_before_page(range, pgstart))  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">  </div><div class="line">        <span class="comment">/* </span></div><div class="line">         * The user can ask us to pin pages that span multiple ranges, </div><div class="line">         * or to pin pages that aren't even unpinned, so this is messy. </div><div class="line">         * </div><div class="line">         * Four cases: </div><div class="line">         * 1. The requested range subsumes an existing range, so we </div><div class="line">         *    just remove the entire matching range. </div><div class="line">         * 2. The requested range overlaps the start of an existing </div><div class="line">         *    range, so we just update that range. </div><div class="line">         * 3. The requested range overlaps the end of an existing </div><div class="line">         *    range, so we just update that range. </div><div class="line">         * 4. The requested range punches a hole in an existing range, </div><div class="line">         *    so we have to update one side of the range and then </div><div class="line">         *    create a new range for the other side. </div><div class="line">         */  </div><div class="line">        <span class="keyword">if</span> (page_range_in_range(range, pgstart, pgend)) &#123;  </div><div class="line">            ret |= range-&gt;purged;  </div><div class="line">  </div><div class="line">            <span class="comment">/* Case #1: Easy. Just nuke the whole thing. */</span>  </div><div class="line">            <span class="keyword">if</span> (page_range_subsumes_range(range, pgstart, pgend)) &#123;  </div><div class="line">                range_del(range);  </div><div class="line">                <span class="keyword">continue</span>;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            <span class="comment">/* Case #2: We overlap from the start, so adjust it */</span>  </div><div class="line">            <span class="keyword">if</span> (range-&gt;pgstart &gt;= pgstart) &#123;  </div><div class="line">                range_shrink(range, pgend + <span class="number">1</span>, range-&gt;pgend);  </div><div class="line">                <span class="keyword">continue</span>;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            <span class="comment">/* Case #3: We overlap from the rear, so adjust it */</span>  </div><div class="line">            <span class="keyword">if</span> (range-&gt;pgend &lt;= pgend) &#123;  </div><div class="line">                range_shrink(range, range-&gt;pgstart, pgstart<span class="number">-1</span>);  </div><div class="line">                <span class="keyword">continue</span>;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            <span class="comment">/* </span></div><div class="line">             * Case #4: We eat a chunk out of the middle. A bit </div><div class="line">             * more complicated, we allocate a new range for the </div><div class="line">             * second half and adjust the first chunk's endpoint. </div><div class="line">             */  </div><div class="line">            range_alloc(asma, range, range-&gt;purged,  </div><div class="line">                    pgend + <span class="number">1</span>, range-&gt;pgend);  </div><div class="line">            range_shrink(range, range-&gt;pgstart, pgstart - <span class="number">1</span>);  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> ret;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先要执行pin操作的内存块必须要在unpinned_list列表中的，如果不在，就什么都不用做。要判断要pin的内存块是否在unpinned_list列表中，还是要通过遍历相应的asma-&gt;unpinned_list列表来找出与之相交的内存块了。</p>
<h2 id="辅助内存管理"><a href="#辅助内存管理" class="headerlink" title="辅助内存管理"></a>辅助内存管理</h2><p>ashmem_init函数：<br>ashmem_init函数是Ashmem驱动程序模块初始化函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> shrinker ashmem_shrinker = &#123;  </div><div class="line">    .shrink = ashmem_shrink,  </div><div class="line">    .seeks = DEFAULT_SEEKS * <span class="number">4</span>,  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">ashmem_init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> ret;  </div><div class="line">    ......  </div><div class="line">    register_shrinker(&amp;ashmem_shrinker);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用register_shrinker函数向内存管理系统注册一个内存回收算法函数。在Linux内核中，当系统内存紧张时，内存管理系统就会进行内存回收算法，将一些最近没有用过的内存换出物理内存去，这样可以增加物理内存的供应。因此，当内存管理系统进行内存回收时，就会调用到这里的ashmem_shrink函数，让Ashmem驱动程序执行内存回收操作。<br>具体的管理函数可以在kernel/common/mm/memory.c中找到。</p>
<h2 id="简析Ashmen进程间传递"><a href="#简析Ashmen进程间传递" class="headerlink" title="简析Ashmen进程间传递"></a>简析Ashmen进程间传递</h2><p>在Linux系统中，文件描述符其实就是一个整数。每一个进程在内核空间都有一个打开文件的数组，这个文件描述符的整数值就是用来索引这个数组的，而且，这个文件描述符只是在本进程内有效，也就是说，在不同的进程中，相同的文件描述符的值，代表的可能是不同的打开文件。因此，在进程间传输文件描述符时，不能简要地把一个文件描述符从一个进程传给另外一个进程，中间必须做一过转换，使得这个文件描述在目标进程中是有效的，并且它和源进程的文件描述符所对应的打开文件是一致的，这样才能保证共享。</p>
<p>在讲解前了解两个结构体：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * This is the flattened representation of a Binder object for transfer between processes.  The 'offsets' supplied as part of a binder transaction contains offsets into the data where these structures occur.  The Binder  driver takes care of re-writing the structure type and data as it moves  between processes. </div><div class="line"> */  </div><div class="line"><span class="keyword">struct</span> flat_binder_object &#123;  </div><div class="line">    <span class="comment">/* 8 bytes for large_flat_header. */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       type;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;  </div><div class="line">  </div><div class="line">    <span class="comment">/* 8 bytes of data. */</span>  </div><div class="line">    <span class="keyword">union</span> &#123;  </div><div class="line">        <span class="keyword">void</span>        *binder;    <span class="comment">/* local object */</span>  </div><div class="line">        <span class="keyword">signed</span> <span class="keyword">long</span> handle;     <span class="comment">/* remote object */</span>  </div><div class="line">    &#125;;  </div><div class="line">  </div><div class="line">    <span class="comment">/* extra data associated with local object */</span>  </div><div class="line">    <span class="keyword">void</span>            *cookie;  </div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="keyword">enum</span> &#123;  </div><div class="line">    BINDER_TYPE_BINDER  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),  </div><div class="line">    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),  </div><div class="line">    BINDER_TYPE_HANDLE  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),  </div><div class="line">    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),  </div><div class="line">    BINDER_TYPE_FD      = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在binder里关键的结构体flat_binder_object中，主要看的type是BINDER_TYPE_FD，要传输的文件描述符的值保存在handle域中。</p>
<p>文件描述符类型的Binder对象在Binder驱动程序中的相关处理逻辑实现在binder_transact函数。</p>
<p>binder_transact函数核心功能：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> BINDER_TYPE_FD: &#123;  </div><div class="line">    <span class="keyword">int</span> target_fd;  </div><div class="line">    <span class="keyword">struct</span> file *file;  </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reply) &#123;  </div><div class="line">        <span class="keyword">if</span> (!(in_reply_to-&gt;flags &amp; TF_ACCEPT_FDS)) &#123; </div><div class="line">            return_error = BR_FAILED_REPLY;  </div><div class="line">            <span class="keyword">goto</span> err_fd_not_allowed;  </div><div class="line">        &#125;  </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!target_node-&gt;accept_fds) &#123;  </div><div class="line">        return_error = BR_FAILED_REPLY;  </div><div class="line">        <span class="keyword">goto</span> err_fd_not_allowed;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    file = fget(fp-&gt;handle);  </div><div class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;  </div><div class="line">        return_error = BR_FAILED_REPLY;  </div><div class="line">        <span class="keyword">goto</span> err_fget_failed;  </div><div class="line">    &#125;  </div><div class="line">    target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);  </div><div class="line">    <span class="keyword">if</span> (target_fd &lt; <span class="number">0</span>) &#123;  </div><div class="line">        fput(file);  </div><div class="line">        return_error = BR_FAILED_REPLY;  </div><div class="line">        <span class="keyword">goto</span> err_get_unused_fd_failed;  </div><div class="line">    &#125;  </div><div class="line">    task_fd_install(target_proc, target_fd, file);  </div><div class="line">     </div><div class="line">    <span class="comment">/* <span class="doctag">TODO:</span> fput? */</span>  </div><div class="line">    fp-&gt;handle = target_fd;  </div><div class="line">&#125; <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>代码地址：kernel/common/drivers/staging/android/binder.c<br>最后的功能非常复杂，以后会在详细解析上来分析。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/22/Android-浅析-Ashmem/" data-id="civ9405rc0002akqtrbxhls26" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ashmem/">Ashmem</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-浅析-智能指针" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/10/Android-浅析-智能指针/" class="article-date">
  <time datetime="2015-11-10T08:03:33.000Z" itemprop="datePublished">2015-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/10/Android-浅析-智能指针/">Android 浅析 智能指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Linus Benedict Torvalds : RTFSC – Read The Funning Source Code</p>
</blockquote>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>为了避免像C++指针里的常见问题而重新设计更“安全”的指针。C++中常见的问题：1、指针没初始化；2、new了后忘记delete；3、野指针。</p>
<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>Android中定义了两种智能指针类型，一种是<strong>强指针sp(strong pointer)</strong>，另外一种是<strong>弱指针(weak pointer)</strong>。</p>
<p>强指针sp(strong pointer):<br>与一般意义的智能指针概念相同，通过引用计数来记录有多少使用者在使用一个对象，如果所有使用者都放弃了对该对象的引用，则该对象将被自动销毁。</p>
<p>弱指针(weak pointer):<br>弱指针也指向一个对象，但是弱指针仅仅记录该对象的地址，不能通过弱指针来访问该对象，也就是说不能通过弱指针来调用对象的成员函数或访问对象的成员变量。</p>
<h2 id="指针类实现"><a href="#指针类实现" class="headerlink" title="指针类实现"></a>指针类实现</h2><p>如果要使用智能指针来引用这个类的对象，那么这个类需满足下列两个前提条件：<br>1：这个类是基类RefBase的子类或间接子类；<br>2：这个类必须定义虚构造函数，即它的构造函数需要这样定义：virtual ~MyClass();</p>
<h3 id="轻量级引用计数类LightRefBase"><a href="#轻量级引用计数类LightRefBase" class="headerlink" title="轻量级引用计数类LightRefBase"></a>轻量级引用计数类LightRefBase</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class LightRefBase</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    inline LightRefBase() : mCount(0) &#123;&#125;</div><div class="line">    inline void incStrong(const void* id) const &#123;</div><div class="line">        android_atomic_inc(&amp;mCount);</div><div class="line">    &#125;</div><div class="line">    inline void decStrong(const void* id) const &#123;</div><div class="line">        if (android_atomic_dec(&amp;mCount) == 1) &#123;</div><div class="line">            delete static_cast&lt;const T*&gt;(this);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //! DEBUGGING ONLY: Get current strong ref count.</div><div class="line">    inline int32_t getStrongCount() const &#123;return mCount;&#125;</div><div class="line">protected:</div><div class="line">    inline ~LightRefBase() &#123; &#125;</div><div class="line">private:</div><div class="line">    mutable volatile int32_t mCount;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>android_atomic_inc()<a href="//原子操作增加">^footnote</a><br>android_atomic_dec()<a href="//原子操作减少">^footnote2</a><br>计数器，递减到0的时候就delete掉对象。</p>
<h3 id="重量级引用计数类-RefBase"><a href="#重量级引用计数类-RefBase" class="headerlink" title="重量级引用计数类 RefBase"></a>重量级引用计数类 RefBase</h3><p>不同于LightRefBase的是，RefBase内部并没有使用一个变量来维护引用计数，而是通过一个weakref_impl *类型的成员来维护引用计数，并且同时提供了强引用计数和弱引用计数。weakref_impl继承于RefBase::weakref_type。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> RefBase  </div><div class="line">&#123;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="function"><span class="keyword">void</span>            <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">void</span>            <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">void</span>            <span class="title">forceIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">class</span> weakref_type  </div><div class="line">    &#123;  </div><div class="line">    <span class="keyword">public</span>:  </div><div class="line">        <span class="function">RefBase*            <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;  </div><div class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;  </div><div class="line">  </div><div class="line">        <span class="comment">//! This is only safe if you have set OBJECT_LIFETIME_FOREVER.  </span></div><div class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;  </div><div class="line">    &#125;;  </div><div class="line">  </div><div class="line">    <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;  </div><div class="line">  </div><div class="line">    <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  </div><div class="line"><span class="keyword">protected</span>:  </div><div class="line">    RefBase();  </div><div class="line">    <span class="keyword">virtual</span>                 ~RefBase();  </div><div class="line">  </div><div class="line">    <span class="comment">//! Flags for extendObjectLifetime()  </span></div><div class="line">    <span class="keyword">enum</span> &#123;  </div><div class="line">        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,  </div><div class="line">        OBJECT_LIFETIME_FOREVER = <span class="number">0x0003</span>  </div><div class="line">    &#125;;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">void</span>            <span class="title">extendObjectLifetime</span><span class="params">(<span class="keyword">int32_t</span> mode)</span></span>;  </div><div class="line">  </div><div class="line">    <span class="comment">//! Flags for onIncStrongAttempted()  </span></div><div class="line">    <span class="keyword">enum</span> &#123;  </div><div class="line">        FIRST_INC_STRONG = <span class="number">0x0001</span>  </div><div class="line">    &#125;;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;  </div><div class="line">  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> weakref_type;  </div><div class="line">    <span class="keyword">class</span> weakref_impl;  </div><div class="line">  </div><div class="line">    RefBase(<span class="keyword">const</span> RefBase&amp; o);  </div><div class="line">    RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);  </div><div class="line">  </div><div class="line">    weakref_impl* <span class="keyword">const</span> mRefs;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>RefBase类的成员变量mRefs的类型为weakref_impl指针，在去除debug代码后：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> RefBase::weakref_impl : <span class="keyword">public</span> RefBase::weakref_type</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mStrong;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mWeak;</div><div class="line">    RefBase* <span class="keyword">const</span>      mBase;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mFlags;</div><div class="line">    Destroyer*          mDestroyer;</div><div class="line"></div><div class="line">    weakref_impl(RefBase* base)</div><div class="line">        : mStrong(INITIAL_STRONG_VALUE)</div><div class="line">        , mWeak(<span class="number">0</span>)</div><div class="line">        , mBase(base)</div><div class="line">        , mFlags(<span class="number">0</span>)</div><div class="line">        , mDestroyer(<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span>, <span class="keyword">bool</span>)</span> </span>&#123; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>类图：<br><img src="http://ww4.sinaimg.cn/large/7669bef3gw1ewuny9tan9j20j909b409.jpg" alt="RefBase"></p>
<h3 id="强指针数类-sp"><a href="#强指针数类-sp" class="headerlink" title="强指针数类 sp"></a>强指针数类 sp</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">template &lt;typename T&gt;  </div><div class="line">class sp  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">    typedef typename RefBase::weakref_type weakref_type;  </div><div class="line">  </div><div class="line">    inline sp() : m_ptr(0) &#123; &#125;  </div><div class="line">  </div><div class="line">    sp(T* other);  </div><div class="line">    sp(const sp&lt;T&gt;&amp; other);  </div><div class="line">    template&lt;typename U&gt; sp(U* other);  </div><div class="line">    template&lt;typename U&gt; sp(const sp&lt;U&gt;&amp; other);  </div><div class="line">  </div><div class="line">    ~sp();  </div><div class="line">  </div><div class="line">    sp&amp; operator = (T* other);  </div><div class="line">    sp&amp; operator = (const sp&lt;T&gt;&amp; other);  </div><div class="line">  </div><div class="line">    template&lt;typename U&gt; sp&amp; operator = (const sp&lt;U&gt;&amp; other);  </div><div class="line">    template&lt;typename U&gt; sp&amp; operator = (U* other);  </div><div class="line">  </div><div class="line">    //! Special optimization for use by ProcessState (and nobody else).  </div><div class="line">    void force_set(T* other);  </div><div class="line">  </div><div class="line">    void clear();  </div><div class="line">  </div><div class="line">    inline  T&amp;      operator* () const  &#123; return *m_ptr; &#125;  </div><div class="line">    inline  T*      operator-&gt; () const &#123; return m_ptr;  &#125;  </div><div class="line">    inline  T*      get() const         &#123; return m_ptr; &#125;  </div><div class="line">  </div><div class="line">    // Operators  </div><div class="line">  </div><div class="line">    COMPARE(==)  </div><div class="line">        COMPARE(!=)  </div><div class="line">        COMPARE(&gt;)  </div><div class="line">        COMPARE(&lt;)  </div><div class="line">        COMPARE(&lt;=)  </div><div class="line">        COMPARE(&gt;=)  </div><div class="line">  </div><div class="line">private:  </div><div class="line">    template&lt;typename Y&gt; friend class sp;  </div><div class="line">    template&lt;typename Y&gt; friend class wp;  </div><div class="line">  </div><div class="line">    // Optimization for wp::promote().  </div><div class="line">    sp(T* p, weakref_type* refs);  </div><div class="line">  </div><div class="line">    T*              m_ptr;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用轻量级引用计数：<br>重点只关注成员变量m_ptr、构造函数和析构函数；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造函数里面都是初始化了成员变量，并且调用变量的incStrong函数来增加对象的引用计数。</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </div><div class="line">sp&lt;T&gt;::sp(T* other)  </div><div class="line">    : m_ptr(other)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (other) other-&gt;incStrong(<span class="keyword">this</span>);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </div><div class="line">sp&lt;T&gt;::sp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)  </div><div class="line">    : m_ptr(other.m_ptr)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (m_ptr) m_ptr-&gt;incStrong(<span class="keyword">this</span>);  </div><div class="line">&#125;</div><div class="line"><span class="comment">//析构函数调用m_ptr的成员函数decStrong来减少对象的引用计数值</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </div><div class="line">sp&lt;T&gt;::~sp()  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (m_ptr) m_ptr-&gt;decStrong(<span class="keyword">this</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继承轻量级引用计数使用例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> LightClass : <span class="keyword">public</span> LightRefBase&lt;LightClass&gt;  </div><div class="line">&#123;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">        LightClass() &#123;&#125;  </div><div class="line">        <span class="keyword">virtual</span> ~LightClass() &#123;&#125;  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>  </span></div><div class="line">&#123;  </div><div class="line">        LightClass* pLightClass = <span class="keyword">new</span> LightClass();  </div><div class="line">        sp&lt;LightClass&gt; lpOut = pLightClass;  </div><div class="line">        &#123;  </div><div class="line">                sp&lt;LightClass&gt; lpInner = lpOut;</div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用重量级引用计数：<br>强指针：<br>使用重量级引用计数一定是继承于RefBase类，在构造函数传进来的就是RefBase类，调用的是RefBase类的incStrong函数。<br>在RefBase类的incStrong函数中，主要做了三件事情：一是增加弱引用计数；二是增加强引用计数；三是如果发现是首次调用这个对象的incStrong函数，就会调用一个这个对象的onFirstRef函数，让对象有机会在对象被首次引用时做一些处理逻辑。<br>总体来说强指针类sp在其构造函数里面所做的事情就是分别为目标对象的强引用计数和弱引和计数增加了1。<br>在析构函数里，如果发现减1前，此对象的强引用计数为1，就说明从此以后，就再没有地方引用这个目标对象了，这时候，就要看看是否要delete这个目标对象了，在强引用计数为0的情况下，如果对象的标志位OBJECT_LIFETIME_WEAK被设置了，就说明这个对象的生命周期是受弱引用计数所控制的，因此，这时候就不能delete对象，要等到弱引用计数也为0的情况下，才能delete这个对象。<br>总结：<br>A：如果对象的标志位被设置为0，那么只要发现对象的强引用计数值为0，那就会自动delete掉这个对象；<br>B：如果对象的标志位被设置为OBJECT_LIFETIME_WEAK，那么只有当对象的强引用计数和弱引用计数都为0的时候，才会自动delete掉这个对象；<br>C：如果对象的标志位被设置为OBJECT_LIFETIME_FOREVER，那么对象就永远不会自动被delete掉，谁new出来的对象谁来delete掉。</p>
<h3 id="弱指针数类-wp"><a href="#弱指针数类-wp" class="headerlink" title="弱指针数类 wp"></a>弱指针数类 wp</h3><p>弱指针所使用的引用计数类与强指针一样，都是RefBase类。<br>弱指针的最大特点是它不能直接操作目标对象，因为弱指针类没有重载*和-&gt;操作符号，而强指针重载了这两个操作符号。如果我们要操作目标对象，就要把弱指针升级为强指针。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </div><div class="line">sp&lt;T&gt; wp&lt;T&gt;::promote() <span class="keyword">const</span>  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">return</span> sp&lt;T&gt;(m_ptr, m_refs);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="强弱指针用法"><a href="#强弱指针用法" class="headerlink" title="强弱指针用法"></a>强弱指针用法</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;  </div><div class="line">#include &lt;utils/RefBase.h&gt;  </div><div class="line">  </div><div class="line">#define INITIAL_STRONG_VALUE (1&lt;&lt;28)  </div><div class="line">  </div><div class="line">using namespace android;  </div><div class="line">  </div><div class="line">class WeightClass : public RefBase  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">        void printRefCount()  </div><div class="line">        &#123;  </div><div class="line">                int32_t strong = getStrongCount();  </div><div class="line">                weakref_type* ref = getWeakRefs();  </div><div class="line">  </div><div class="line">                printf("-----------------------\n");  </div><div class="line">                printf("Strong Ref Count: %d.\n", (strong  == INITIAL_STRONG_VALUE ? 0 : strong));  </div><div class="line">                printf("Weak Ref Count: %d.\n", ref-&gt;getWeakCount());  </div><div class="line">                printf("-----------------------\n");  </div><div class="line">        &#125;  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line">class StrongClass : public WeightClass  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">        StrongClass()  </div><div class="line">        &#123;  </div><div class="line">                printf("Construct StrongClass Object.\n");  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        virtual ~StrongClass()  </div><div class="line">        &#123;  </div><div class="line">                printf("Destory StrongClass Object.\n");  </div><div class="line">        &#125;  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line">  </div><div class="line">class WeakClass : public WeightClass  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">        WeakClass()  </div><div class="line">        &#123;  </div><div class="line">                extendObjectLifetime(OBJECT_LIFETIME_WEAK);  </div><div class="line">  </div><div class="line">                printf("Construct WeakClass Object.\n");  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        virtual ~WeakClass()  </div><div class="line">        &#123;  </div><div class="line">                printf("Destory WeakClass Object.\n");  </div><div class="line">        &#125;  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line">class ForeverClass : public WeightClass  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">        ForeverClass()  </div><div class="line">        &#123;  </div><div class="line">                extendObjectLifetime(OBJECT_LIFETIME_FOREVER);  </div><div class="line">  </div><div class="line">                printf("Construct ForeverClass Object.\n");  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        virtual ~ForeverClass()  </div><div class="line">        &#123;  </div><div class="line">                printf("Destory ForeverClass Object.\n");  </div><div class="line">        &#125;  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line">  </div><div class="line">void TestStrongClass(StrongClass* pStrongClass)  </div><div class="line">&#123;  </div><div class="line">        wp&lt;StrongClass&gt; wpOut = pStrongClass;  </div><div class="line">        pStrongClass-&gt;printRefCount();  </div><div class="line">  </div><div class="line">        &#123;  </div><div class="line">                sp&lt;StrongClass&gt; spInner = pStrongClass;  </div><div class="line">                pStrongClass-&gt;printRefCount();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        sp&lt;StrongClass&gt; spOut = wpOut.promote();  </div><div class="line">        printf("spOut: %p.\n", spOut.get());  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">void TestWeakClass(WeakClass* pWeakClass)  </div><div class="line">&#123;  </div><div class="line">        wp&lt;WeakClass&gt; wpOut = pWeakClass;  </div><div class="line">        pWeakClass-&gt;printRefCount();  </div><div class="line">  </div><div class="line">        &#123;  </div><div class="line">                sp&lt;WeakClass&gt; spInner = pWeakClass;  </div><div class="line">                pWeakClass-&gt;printRefCount();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        pWeakClass-&gt;printRefCount();  </div><div class="line">        sp&lt;WeakClass&gt; spOut = wpOut.promote();  </div><div class="line">        printf("spOut: %p.\n", spOut.get());  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">void TestForeverClass(ForeverClass* pForeverClass)  </div><div class="line">&#123;  </div><div class="line">        wp&lt;ForeverClass&gt; wpOut = pForeverClass;  </div><div class="line">        pForeverClass-&gt;printRefCount();  </div><div class="line">  </div><div class="line">        &#123;  </div><div class="line">                sp&lt;ForeverClass&gt; spInner = pForeverClass;  </div><div class="line">                pForeverClass-&gt;printRefCount();  </div><div class="line">        &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">int main(int argc, char** argv)  </div><div class="line">&#123;  </div><div class="line">        printf("Test Strong Class: \n");  </div><div class="line">        StrongClass* pStrongClass = new StrongClass();  </div><div class="line">        TestStrongClass(pStrongClass);  </div><div class="line">  </div><div class="line">        printf("\nTest Weak Class: \n");  </div><div class="line">        WeakClass* pWeakClass = new WeakClass();  </div><div class="line">        TestWeakClass(pWeakClass);  </div><div class="line">  </div><div class="line">        printf("\nTest Froever Class: \n");  </div><div class="line">        ForeverClass* pForeverClass = new ForeverClass();  </div><div class="line">        TestForeverClass(pForeverClass);  </div><div class="line">        pForeverClass-&gt;printRefCount();  </div><div class="line">        delete pForeverClass;  </div><div class="line">  </div><div class="line">        return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/10/Android-浅析-智能指针/" data-id="civ9405sn0015akqt4l4kqfkk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/智能指针/">智能指针</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/FreeLoad/">FreeLoad</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-基础知识/">Android_基础知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ashmem/">Ashmem</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder/">Binder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Broadcast/">Broadcast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ButterKnife/">ButterKnife</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ContentProvider/">ContentProvider</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EventBus/">EventBus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FreeLoad/">FreeLoad</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SharedPreferences/">SharedPreferences</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源库/">开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/智能指针/">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注解/">注解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-基础知识/" style="font-size: 18.33px;">Android_基础知识</a> <a href="/tags/Ashmem/" style="font-size: 10px;">Ashmem</a> <a href="/tags/Binder/" style="font-size: 13.33px;">Binder</a> <a href="/tags/Broadcast/" style="font-size: 13.33px;">Broadcast</a> <a href="/tags/ButterKnife/" style="font-size: 11.67px;">ButterKnife</a> <a href="/tags/ContentProvider/" style="font-size: 15px;">ContentProvider</a> <a href="/tags/EventBus/" style="font-size: 11.67px;">EventBus</a> <a href="/tags/FreeLoad/" style="font-size: 10px;">FreeLoad</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/RxJava/" style="font-size: 11.67px;">RxJava</a> <a href="/tags/SharedPreferences/" style="font-size: 11.67px;">SharedPreferences</a> <a href="/tags/Volley/" style="font-size: 11.67px;">Volley</a> <a href="/tags/开源库/" style="font-size: 16.67px;">开源库</a> <a href="/tags/智能指针/" style="font-size: 10px;">智能指针</a> <a href="/tags/注解/" style="font-size: 10px;">注解</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/08/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/09/22/Android-浅析-RxJava-二-原理/">Android 浅析 RxJava (二) 原理</a>
          </li>
        
          <li>
            <a href="/2016/09/22/Android-浅析-RxJava-一-使用/">Android 浅析 RxJava (一) 使用</a>
          </li>
        
          <li>
            <a href="/2016/09/21/Java-注解-Dependency-injection/">Java 注解 Dependency injection</a>
          </li>
        
          <li>
            <a href="/2016/09/21/Android-浅析-ButterKnife-二-源码解析/">Android 浅析 ButterKnife (二) 源码解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>